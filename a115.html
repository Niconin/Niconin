<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>AI Chess - Ultimate Green (Ver.Mesugaki)</title>

<link rel="stylesheet" href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css">

<style>
  /* === 1. å…¨ä½“è¨­å®š === */
  body {
    margin: 0; font-family: 'Helvetica Neue', Arial, sans-serif;
    background: linear-gradient(135deg, #134E5E, #71B280);
    height: 100vh; display: flex; justify-content: center; align-items: center;
    overflow: hidden; color: #fff;
  }

  /* === 2. ãƒ¡ã‚¤ãƒ³ãƒœãƒƒã‚¯ã‚¹ === */
  .box {
    background: rgba(255, 255, 255, 0.95);
    color: #333;
    padding: 20px; border-radius: 15px;
    box-shadow: 0 20px 50px rgba(0,0,0,0.5);
    display: flex; gap: 25px;
    max-width: 950px; width: 95%; height: 90vh;
    position: relative;
  }

  /* === 3. ç›¤é¢ã‚¨ãƒªã‚¢ === */
  .board-section {
    flex: 2; display: flex; flex-direction: column; justify-content: center; align-items: center;
  }
  .board-wrap {
    border: 5px solid #2E7D32;
    border-radius: 4px;
    box-shadow: 0 5px 15px rgba(0,0,0,0.2);
    width: 100%; max-width: 600px;
    aspect-ratio: 1 / 1; 
  }

  /* === 4. æƒ…å ±ã‚¨ãƒªã‚¢ === */
  .info-section {
    flex: 1; display: flex; flex-direction: column; align-items: center;
    overflow-y: auto; padding: 10px;
  }

  /* === 5. ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ & ã‚²ãƒ¼ã‚¸ === */
  .mascot {
    font-size: 60px; background: #fff;
    width: 90px; height: 90px; border-radius: 50%;
    display: flex; justify-content: center; align-items: center;
    border: 4px solid #ccc; margin-bottom: 5px;
    flex-shrink: 0; transition: 0.3s;
    box-shadow: 0 4px 10px rgba(0,0,0,0.1);
  }
  .active-turn {
    border-color: #2ecc71;
    box-shadow: 0 0 20px rgba(46, 204, 113, 0.6);
    transform: scale(1.05);
  }

  .eval-gauge-container {
    width: 100%; height: 10px; background: #555;
    margin-bottom: 15px; border-radius: 4px; overflow: hidden;
    display: flex; box-shadow: inset 0 1px 3px rgba(0,0,0,0.3);
  }
  .eval-bar-white {
    height: 100%; background: #2ecc71;
    width: 50%; transition: width 0.5s ease-out;
  }
  .eval-bar-black {
    height: 100%; background: #e74c3c;
    width: 50%; /* JSã§åˆ¶å¾¡ */
  }

  /* === 6. å¹ãå‡ºã— === */
  .bubble {
    position: relative; background: #ecf0f1;
    color: #2c3e50; border-radius: 12px;
    padding: 15px; width: 100%; margin-bottom: 15px;
    min-height: 80px; font-size: 14px; box-sizing: border-box;
    border: 2px solid #bdc3c7;
    display: flex; align-items: center; justify-content: center; text-align: center;
    line-height: 1.5;
  }
  .bubble::after {
    content: ''; position: absolute; top: -12px; left: 50%;
    transform: translateX(-50%);
    border: 12px solid transparent; border-bottom-color: #bdc3c7;
  }

  /* === ã‚µã‚¤ãƒ‰ãƒãƒ¼ç”¨ãƒ«ãƒ¼ãƒ«ãƒœãƒƒã‚¯ã‚¹ === */
  .sidebar-rules {
    width: 100%;
    background: #f1f8e9; /* è–„ã„ç·‘ */
    border: 1px solid #c5e1a5;
    border-radius: 8px;
    padding: 10px;
    margin-bottom: 10px;
    font-size: 0.8em; /* æ–‡å­—ã‚µã‚¤ã‚ºèª¿æ•´ */
    color: #33691e;
    box-sizing: border-box;
    text-align: left;
    max-height: 200px;
    overflow-y: auto;
  }
  .sidebar-rules h4 { margin: 0 0 5px 0; border-bottom: 1px solid #aed581; padding-bottom: 3px; }
  .sidebar-rules ul { margin: 0; padding-left: 20px; }
  .sidebar-rules li { margin-bottom: 3px; }
  .piece-help { font-size: 0.9em; color: #558b2f; margin-top:5px; }

  /* === 7. ãƒœã‚¿ãƒ³é¡ === */
  .btn-group {
    width: 100%; display: flex; flex-direction: column;
    gap: 8px; margin-top: auto;
  }
  .btn {
    border: none; padding: 10px; border-radius: 8px;
    font-weight: bold; cursor: pointer; width: 100%;
    color: white; transition: 0.2s; font-size: 14px;
    display: block; 
  }
  .btn-hint { background: #e67e22; } .btn-hint:hover { background: #d35400; }
  .btn-undo { background: #9b59b6; } .btn-undo:hover { background: #8e44ad; } 
  .btn-auto { background: #2ecc71; } .btn-auto:hover { background: #27ae60; }
  .btn-retry { background: #3498db; } .btn-retry:hover { background: #2980b9; }
  .btn-reset { background: #95a5a6; } .btn-reset:hover { background: #7f8c8d; }
    
  .btn-auto-active {
    background: #e74c3c; animation: pulse 1s infinite alternate;
  }
  @keyframes pulse { from { opacity: 1; } to { opacity: 0.8; } }
  .btn-disabled { background: #bdc3c7 !important; cursor: not-allowed; opacity: 0.6; }

  .hidden { display: none !important; }

  /* === 8. ã‚¹ã‚¿ãƒ¼ãƒˆç”»é¢ === */
  .overlay {
    position: absolute; top: 0; left: 0;
    width: 100%; height: 100%;
    background: rgba(20, 50, 30, 0.98);
    z-index: 100; display: flex; flex-direction: column;
    justify-content: center; align-items: center; color: #fff;
    border-radius: 15px; padding: 20px; box-sizing: border-box;
  }
  
  .menu-content {
    display: flex; flex-direction: column; align-items: center;
    width: 100%; max-width: 400px;
  }
  .menu-btn {
    background: #2ecc71; color: #fff; font-weight: bold; cursor: pointer; margin-top: 30px;
    padding: 12px 30px; font-size: 18px; border:none; border-radius: 5px;
    box-shadow: 0 4px 0 #27ae60; transition: 0.1s; width: 100%;
  }
  .menu-btn:active { box-shadow: 0 2px 0 #27ae60; transform: translateY(2px); }

  /* === 9. ãƒã‚¤ãƒ©ã‚¤ãƒˆ === */
  .highlight-move {
    background: radial-gradient(circle, rgba(46, 204, 113, 0.7) 20%, transparent 20%);
  }
  .highlight-capture {
    background-color: rgba(231, 76, 60, 0.5);
    box-shadow: inset 0 0 0 4px rgba(192, 57, 43, 0.8);
  }
  .highlight-hint {
    background: rgba(255, 235, 59, 0.5);
    box-shadow: inset 0 0 20px rgba(255, 235, 59, 0.9);
    animation: flash-yellow 1.0s infinite alternate;
  }
  @keyframes flash-yellow { from { opacity: 0.6; } to { opacity: 1.0; } }

  @media(max-width:768px){
    .box { flex-direction: column; height: auto; overflow-y: auto; }
    .info-section { order: -1; width:100%; } 
    .board-wrap { width: 100%; height: auto; aspect-ratio: 1/1; }
  }
</style>
</head>
<body>

<div class="box">
  <div id="menu" class="overlay">
    <div class="menu-content">
      <h1 style="font-size:2.5em; margin:0 0 20px 0;">â™š AI Chess</h1>
      <a href="a10.html">Ver.0.1.0ã¸</a><a href="a138.html">Ver.1.3.8(æœ€æ–°)ã¸</a>
      <div style="display:flex; gap:20px; width:100%; justify-content:space-between;">
        <div style="text-align:center; flex:1;">
          <p style="margin-bottom:5px; font-weight:bold;">è‡ªåˆ†ã®è‰²</p>
          <select id="color-select" style="font-size:16px; padding:8px; width:100%; border-radius:4px;">
            <option value="w" selected>â™” å…ˆæ‰‹ (ç™½)</option>
            <option value="b">â™š å¾Œæ‰‹ (é»’)</option>
          </select>
        </div>
        <div style="text-align:center; flex:1;">
          <p style="margin-bottom:5px; font-weight:bold;">AIã®å¼·ã•</p>
          <select id="level" style="font-size:16px; padding:8px; width:100%; border-radius:4px;">
            <option value="1">ğŸŒ± åˆç´š (ã–ã“)</option>
            <option value="2">ğŸŒ² ä¸­ç´š (ãµã¤ã†)</option>
            <option value="3" selected>ğŸ‰ ä¸Šç´š (ã¤ã‚ˆã¤ã‚ˆ)</option>
          </select>
        </div>
      </div>

      <button class="menu-btn" onclick="startGame()">ğŸ® ã‚²ãƒ¼ãƒ ã‚¹ã‚¿ãƒ¼ãƒˆï¼</button>
    </div>
  </div>

  <div class="board-section">
    <div class="board-wrap">
      <div id="board" style="width:100%"></div>
    </div>
  </div>

  <div class="info-section">
    <div class="mascot" id="face">ğŸ˜</div>
    <div class="eval-gauge-container" title="å„ªå‹¢ã‚²ãƒ¼ã‚¸">
        <div id="eval-bar-white" class="eval-bar-white"></div>
        <div id="eval-bar-black" class="eval-bar-black" style="background:#555; width:0;"></div>
    </div>

    <div id="status" style="font-weight:bold; margin-bottom:5px; min-height:1.2em;">æº–å‚™å®Œäº†ï¼</div>
    <div class="bubble" id="msg">è¨­å®šã‚’é¸ã‚“ã§ã‚¹ã‚¿ãƒ¼ãƒˆã—ã¦ã­ï¼</div>
    
    <div class="sidebar-rules">
        <h4>ğŸ“œ ã–ã“ã–ã“ãƒ«ãƒ¼ãƒ« & å‹•ãæ–¹</h4>
        <ul>
            <li>ç‹æ§˜(ã‚­ãƒ³ã‚°)ã‚’è©°ã¾ã›ã°å‹ã¡â™¥</li>
            <li>é§’ã¯ãƒ‰ãƒ©ãƒƒã‚°ã§å‹•ã‹ã—ã¦ã­ã€‚</li>
        </ul>
        <div class="piece-help">
            <b>â™™ãƒãƒ¼ãƒ³(æ­©)</b>: å‰ã«1æ­©ã€‚æ•µã¯æ–œã‚ã§å–ã‚‹ã€‚<br>
            <b>â™˜ãƒŠã‚¤ãƒˆ(é¦¬)</b>: Lå­—ã«ã‚¸ãƒ£ãƒ³ãƒ—ã€‚<br>
            <b>â™—ãƒ“ã‚·ãƒ§ãƒƒãƒ—(è§’)</b>: æ–œã‚ã«ã©ã“ã¾ã§ã‚‚ã€‚<br>
            <b>â™–ãƒ«ãƒ¼ã‚¯(é£›)</b>: ç¸¦æ¨ªã«ã©ã“ã¾ã§ã‚‚ã€‚<br>
            <b>â™•ã‚¯ã‚¤ãƒ¼ãƒ³</b>: ç¸¦æ¨ªæ–œã‚ã€‚æœ€å¼·ã€‚<br>
            <b>â™”ã‚­ãƒ³ã‚°(ç‹)</b>: å‘¨å›²ã«1æ­©ã€‚
        </div>
    </div>

    <div class="btn-group">
      <button class="btn btn-hint" id="btn-hint" onclick="showHint()">ğŸ’¡ ãƒ’ãƒ³ãƒˆ</button>
      <button class="btn btn-undo" id="btn-undo" onclick="undoMove()">â†©ï¸ å¾…ã£ãŸ (ã‚„ã‚Šç›´ã—)</button>
      <button class="btn btn-auto" id="btn-auto" onclick="toggleAutoPlay()">ğŸ¤– ã‚ªãƒ¼ãƒˆ: OFF</button>
      
      <button class="btn btn-retry hidden" id="btn-retry" onclick="startGame()">ğŸ”„ ã‚‚ã†ä¸€åº¦éŠã¶</button>

      <button class="btn btn-reset" onclick="location.reload()">ğŸ  ã‚¿ã‚¤ãƒˆãƒ«ã«æˆ»ã‚‹</button>
    </div>
  </div>
</div>

<script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
<script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>

<script>
// === ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•° ===
const game = new Chess();
let board = null;
let aiLevel = 1; 
let isAuto = false;
let autoTimer = null;
let playerColor = 'w';
let audioCtx = null;

// === çµµæ–‡å­—è¨­å®š ===
const EMOJI_SELF = "ğŸ§™â€â™‚ï¸";  // è‡ªåˆ†ï¼ˆé­”æ³•ä½¿ã„ï¼‰
const EMOJI_ROBOT = "ğŸ¤–"; // è‡ªåˆ†ï¼ˆã‚ªãƒ¼ãƒˆãƒ¢ãƒ¼ãƒ‰ï¼‰
const EMOJI_SCARED = "ğŸ˜±"; // è‡ªåˆ†ï¼ˆç‹æ‰‹æ™‚ï¼‰

// æ•µã®é¡”ãƒãƒªã‚¨ãƒ¼ã‚·ãƒ§ãƒ³
const EMOJI_ENEMY_NEUTRAL = ["ğŸ˜", "ğŸ™‚", "ğŸ˜—"];
const EMOJI_ENEMY_WINNING = ["ğŸ˜", "ğŸ¤­", "ğŸ˜ˆ", "ğŸ˜"]; // æ•µãŒå„ªå‹¢ï¼ˆãƒ‹ãƒ¤ã‘ï¼‰
const EMOJI_ENEMY_LOSING = ["ğŸ˜£", "ğŸ˜–", "ğŸ˜¡", "ğŸ¥º"];  // æ•µãŒåŠ£å‹¢ï¼ˆç„¦ã‚Šï¼‰
const EMOJI_ENEMY_CHECKED = ["ğŸ˜³", "ğŸ˜§"];             // æ•µãŒç‹æ‰‹ã•ã‚Œã¦ã„ã‚‹

// ãƒ©ãƒ³ãƒ€ãƒ å–å¾—ãƒ˜ãƒ«ãƒ‘ãƒ¼
function getRandom(arr) {
    return arr[Math.floor(Math.random() * arr.length)];
}

// UIå‚ç…§ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥
const ui = {
  face: $('#face'),
  msg: $('#msg'),
  status: $('#status'),
  btnAuto: $('#btn-auto'),
  btnHint: $('#btn-hint'),
  btnUndo: $('#btn-undo'),
  btnRetry: $('#btn-retry'),
  evalWhite: $('#eval-bar-white')
};

// é§’ã®ç”»åƒç”Ÿæˆ
const pieceTheme = piece => {
  const color = piece[0] === 'w' ? '#fff' : '#000';
  const stroke = piece[0] === 'w' ? '#000' : '#fff';
  const symbols = {'P':'â™™','N':'â™˜','B':'â™—','R':'â™–','Q':'â™•','K':'â™”','p':'â™Ÿ','n':'â™','b':'â™','r':'â™œ','q':'â™›','k':'â™š'};
  return 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(`
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 60 60">
      <text x="50%" y="58%" text-anchor="middle" dominant-baseline="middle" 
            font-family="sans-serif" font-size="50" fill="${color}" stroke="${stroke}" stroke-width="1.5">
        ${symbols[piece[1]] || 'â™Ÿ'}
      </text>
    </svg>`);
};

// === ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è¾æ›¸ (ãƒ¡ã‚¹ã‚¬ã‚­é¢¨ãƒ»æ•µè¦–ç‚¹) ===
const msgDict = {
  start: ["ã¸ã‡ã€ç§ã«æŒ‘ã‚€ã‚“ã ï¼Ÿ ç”Ÿæ„æ°—ã€œâ™¥","ãƒœã‚³ãƒœã‚³ã«ã—ã¦ã‚ã’ã‚‹ã‹ã‚‰è¦šæ‚Ÿã—ã¦ã­â™ª","ãƒ«ãƒ¼ãƒ«ã‚ã‹ã£ã¦ã‚‹ï¼Ÿ é›‘é­šãŠã˜ã•ã‚“ï½—","æ‰‹åŠ æ¸›ãªã—ã§ã„ãã‚ˆï¼Ÿ æ³£ã‹ãªã„ã§ã­ï¼Ÿ"],
  
  playerTurn: ["æ—©ãã—ã¦ã‚ˆã€ã‚ãã³å‡ºã¡ã‚ƒã†ã˜ã‚ƒã‚“ï½—","ãˆã£ã€ãã“ã§é•·è€ƒï¼Ÿ é ­å¤§ä¸ˆå¤«ï¼Ÿ","ã¾ã æ±ºã¾ã‚‰ãªã„ã®ï¼Ÿ å„ªæŸ”ä¸æ–­ã ãªã...","ã¾ã•ã‹...é€ƒã’ã‚‹ã“ã¨è€ƒãˆã¦ã‚‹ï¼Ÿ"],
  robotTurn: ["ãƒ­ãƒœãƒƒãƒˆé ¼ã¿ã¨ã‹...ãƒ—ãƒ©ã‚¤ãƒ‰ãªã„ã®ï¼Ÿï½—","æ‰€è©®ã¯æ©Ÿæ¢°ã ã­ã€å‹•ããŒå˜èª¿ï½—","ã¸ã‡ã€ãã®ãƒãƒ³ã‚³ãƒ„ã§ç§ã«å‹ã¤ã¤ã‚‚ã‚Šï¼Ÿ","è¦‹ã¦ã‚‹ã ã‘ã§æ¥½ãã†ã ã­ã€é›‘é­šãŠã˜ã•ã‚“â™¥"],
  
  aiThink: ["ã‚“ã€œã€ã©ã“ã‹ã‚‰å£Šã—ã¦ã‚ã’ã‚ˆã†ã‹ãªã€œâ™¥","é›‘é­šã®æ€è€ƒãªã‚“ã¦ãŠè¦‹é€šã—ã ã—ï½—","æ¬¡ã¯ã©ã†ã‚„ã£ã¦æ³£ã‹ãã†ã‹ãªâ™ª","è¨ˆç®—ã™ã‚‹ã¾ã§ã‚‚ãªã„ã‘ã©ã€ä¸€å¿œã­..."],
  
  check: ["ã‚ã£ã¯ã¯ï¼ ç‹æ§˜æ­»ã«ãã†ã ã‚ˆï¼Ÿ","ãƒã‚§ãƒƒã‚¯ã€œâ™ª é€ƒã’å›ã‚‹å§¿ãŒæ»‘ç¨½ã ã­ï½—","ã»ã‚‰ã»ã‚‰ã€ç‹æ‰‹ã ã‚ˆï¼Ÿ æ°—ã¥ã„ã¦ã‚‹ï¼Ÿ","ãã“ã©ã‹ãªã„ã¨æ­»ã‚“ã˜ã‚ƒã†ã‚ˆã€œâ™¥"],
  capture: ["ã„ãŸã ãã€œâ™¥ å¼±ã™ãã§ã—ã‚‡ï½—","ãã®é§’ã€é‚ªé­”ã ã£ãŸã‚“ã ã‚ˆã­ã€œãƒã‚¤ãƒã‚¤â™ª","ã”ã¡ãã†ã•ã¾ï¼ å¤§äº‹ãªé§’ã ã£ãŸã®ã«ã­ï½—","ã‚ãƒ¼ã‚ã€å–ã‚‰ã‚Œã¡ã‚ƒã£ã¦ã‹ã‚ã„ãã€œ"],
  
  badMove: ["ã¯ï¼Ÿ ãã“ç½®ã‘ã‚‹ã‚ã‘ãªã„ã˜ã‚ƒã‚“ï½—","ãƒ«ãƒ¼ãƒ«ã‚‚çŸ¥ã‚‰ãªã„ã®ï¼Ÿ ãƒãƒƒã‚«ã˜ã‚ƒãªã„ï¼Ÿ","å¹»è¦šã§ã‚‚è¦‹ãˆã¦ã‚‹ã®ï¼Ÿ ç—…é™¢è¡Œã‘ã°ï¼Ÿ","ãƒ€ãƒ¡ã«æ±ºã¾ã£ã¦ã‚‹ã§ã—ã‚‡ã€é ­ä½¿ã£ã¦ã‚ˆï½—"],
  
  winning: ["ã‚ã‚Œã‚Œã€œï¼Ÿ ã‚‚ã†è² ã‘ãã†ã˜ã‚ƒã‚“ï½—","é™å‚ãƒœã‚¿ãƒ³ãªã„ã‘ã©ã€å¿ƒæŠ˜ã‚Œã¦ãªã„ï¼Ÿ","ã­ãˆä»Šã©ã‚“ãªæ°—æŒã¡ï¼Ÿ è² ã‘ãã†ãªæ°—æŒã¡ï¼Ÿ"],
  losing: ["ã£...ï¼ èª¿å­ã«ä¹—ã‚‹ãªã‚ˆé›‘é­šãŒ...","ãã¬ã¬...è¨ˆç®—ã¨é•ã†ã‚“ã ã‘ã©...","ã¾ã€ã¾ã æœ¬æ°—å‡ºã—ã¦ãªã„ã ã‘ã ã—ï¼","ã¡ã‚‡ã£ã¨ï¼ä»Šã®ãƒŠã‚·ï¼ ãƒŠã‚·ã ã£ã¦ã°ï¼"],
  
  win: ["ã–ã€œã“â™¥ ã–ã€œã“â™¥ ã‚ˆã£ã‚ã€œã„ï½—","ç§ã®å‹ã¡ã€œï¼ å‡ºç›´ã—ã¦ããªã‚ˆé›‘é­šï½—","ã¯ã„è©°ã¿ã€œï¼ æ‚”ã—ã„ï¼Ÿ ã­ã‡æ‚”ã—ã„ï¼Ÿ","å£ã»ã©ã«ã‚‚ãªã„ã­ã€ãŒã£ã‹ã‚Šã ã‚ãƒ¼"],
  lose: ["ã†ã€å˜˜...ç§ãŒè² ã‘ã‚‹ãªã‚“ã¦...","ãã£...ç”Ÿæ„æ°—ãªã‚“ã ã‚ˆé›‘é­šã®ãã›ã«ï¼","ãƒã‚°ã‚ˆï¼ çµ¶å¯¾ãƒã‚°ï¼ èªã‚ãªã„ã‹ã‚‰ï¼","è¦šãˆã¦ãªã•ã„ã‚ˆ...æ¬¡ã¯çµ¶å¯¾å‹ã¤ã‚“ã ã‹ã‚‰ï¼"],
  draw: ["å¼•ãåˆ†ã‘ã€œï¼Ÿ ã¤ã¾ã‚“ãªã„ã®ãƒ¼ã€‚","ã¡ã£ã€ä»•ç•™ã‚æãªã£ãŸã‹...","åƒæ—¥æ‰‹ï¼Ÿ ãŠäº’ã„æš‡äººã ã­ã‡ï½—"],
  undo: ["ã¯ãï¼Ÿ å¾…ã£ãŸï¼Ÿ ãƒ€ãƒƒã‚µï½—ï½—","é–“é•ãˆã¡ã‚ƒã£ãŸã®ï¼Ÿ ä»•æ–¹ãªã„ãªãï½—","ç‰¹åˆ¥ã«è¨±ã—ã¦ã‚ã’ã‚‹ã€‚æ„Ÿè¬ã—ã¦ã‚ˆã­ï¼Ÿ","ã†ã‚ã€œã€ã‚ºãƒ«ã—ãŸã€œï¼ ã¾ã€ã„ã„ã‘ã©ï½—"]
};

function getRandomMsg(category) {
  const list = msgDict[category];
  return list[Math.floor(Math.random() * list.length)];
}

// === éŸ³éŸ¿ ===
function initAudio() {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  if (audioCtx.state === 'suspended') audioCtx.resume();
}
function playSound(type) {
  if (!audioCtx) return;
  const osc = audioCtx.createOscillator();
  const gainNode = audioCtx.createGain();
  osc.connect(gainNode);
  gainNode.connect(audioCtx.destination);
  const now = audioCtx.currentTime;
  
  if (type === 'move') {
    osc.type = 'triangle'; osc.frequency.setValueAtTime(300, now);
    osc.frequency.exponentialRampToValueAtTime(50, now + 0.1);
    gainNode.gain.setValueAtTime(0.2, now); gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
    osc.start(now); osc.stop(now + 0.1);
  } else if (type === 'capture') {
    osc.type = 'square'; osc.frequency.setValueAtTime(600, now);
    osc.frequency.exponentialRampToValueAtTime(100, now + 0.15);
    gainNode.gain.setValueAtTime(0.2, now); gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
    osc.start(now); osc.stop(now + 0.15);
  } else if (type === 'start') {
    osc.type = 'sine'; osc.frequency.setValueAtTime(440, now);
    osc.frequency.linearRampToValueAtTime(880, now + 0.1);
    gainNode.gain.setValueAtTime(0.1, now); gainNode.gain.linearRampToValueAtTime(0, now + 0.5);
    osc.start(now); osc.stop(now + 0.5);
  }
}

// === AIã‚¨ãƒ³ã‚¸ãƒ³ (é«˜é€ŸåŒ–ç‰ˆ) ===
const pst = {
  p: [ [0,0,0,0,0,0,0,0], [50,50,50,50,50,50,50,50], [10,10,20,30,30,20,10,10], [5,5,10,25,25,10,5,5], [0,0,0,20,20,0,0,0], [5,-5,-10,0,0,-10,-5,5], [5,10,10,-20,-20,10,10,5], [0,0,0,0,0,0,0,0] ],
  n: [ [-50,-40,-30,-30,-30,-30,-40,-50], [-40,-20,0,0,0,0,-20,-40], [-30,0,10,15,15,10,0,-30], [-30,5,15,20,20,15,5,-30], [-30,0,15,20,20,15,0,-30], [-30,5,10,15,15,10,5,-30], [-40,-20,0,5,5,0,-20,-40], [-50,-40,-30,-30,-30,-30,-40,-50] ],
  b: [ [-20,-10,-10,-10,-10,-10,-10,-20], [-10,0,0,0,0,0,0,-10], [-10,0,5,10,10,5,0,-10], [-10,5,5,10,10,5,5,-10], [-10,0,10,10,10,10,0,-10], [-10,10,10,10,10,10,10,-10], [-10,5,0,0,0,0,5,-10], [-20,-10,-10,-10,-10,-10,-10,-20] ],
  r: [ [0,0,0,0,0,0,0,0], [5,10,10,10,10,10,10,5], [-5,0,0,0,0,0,0,-5], [-5,0,0,0,0,0,0,-5], [-5,0,0,0,0,0,0,-5], [-5,0,0,0,0,0,0,-5], [-5,0,0,0,0,0,0,-5], [0,0,0,5,5,0,0,0] ],
  q: [ [-20,-10,-10,-5,-5,-10,-10,-20], [-10,0,0,0,0,0,0,-10], [-10,0,5,5,5,5,0,-10], [-5,0,5,5,5,5,0,-5], [0,0,5,5,5,5,0,-5], [-10,5,5,5,5,5,0,-10], [-10,0,5,0,0,0,0,-10], [-20,-10,-10,-5,-5,-10,-10,-20] ],
  k: [ [-30,-40,-40,-50,-50,-40,-40,-30], [-30,-40,-40,-50,-50,-40,-40,-30], [-30,-40,-40,-50,-50,-40,-40,-30], [-30,-40,-40,-50,-50,-40,-40,-30], [-20,-30,-30,-40,-40,-30,-30,-20], [-10,-20,-20,-20,-20,-20,-20,-10], [20,20,0,0,0,0,20,20], [20,30,10,0,0,10,30,20] ]
};
const PIECE_VALUES = { p: 100, n: 320, b: 330, r: 500, q: 900, k: 20000 };

function evaluateBoard(gameObj) {
  let totalEvaluation = 0;
  const boardData = gameObj.board();
  for (let i = 0; i < 8; i++) {
    for (let j = 0; j < 8; j++) {
      const piece = boardData[i][j];
      if (piece) {
        const type = piece.type;
        const color = piece.color;
        const posVal = (color === 'w') ? pst[type][i][j] : pst[type][7 - i][j];
        const val = PIECE_VALUES[type] + posVal;
        totalEvaluation += (color === 'w' ? val : -val);
      }
    }
  }
  return totalEvaluation;
}

function minimax(gameObj, depth, alpha, beta, isMaximizing) {
  if (depth === 0) return evaluateBoard(gameObj);
  let moves = gameObj.moves();
  if (moves.length === 0) {
    if (gameObj.in_checkmate()) return isMaximizing ? -99999 : 99999;
    return 0; 
  }

  moves.sort((a, b) => {
    const scoreA = (a.indexOf('x') !== -1) ? 10 : 0;
    const scoreB = (b.indexOf('x') !== -1) ? 10 : 0;
    return scoreB - scoreA;
  });

  if (isMaximizing) {
    let maxEval = -Infinity;
    for (let i = 0; i < moves.length; i++) {
      gameObj.move(moves[i]);
      const ev = minimax(gameObj, depth - 1, alpha, beta, false);
      gameObj.undo();
      if (ev > maxEval) maxEval = ev;
      if (ev > alpha) alpha = ev;
      if (beta <= alpha) break;
    }
    return maxEval;
  } else {
    let minEval = Infinity;
    for (let i = 0; i < moves.length; i++) {
      gameObj.move(moves[i]);
      const ev = minimax(gameObj, depth - 1, alpha, beta, true);
      gameObj.undo();
      if (ev < minEval) minEval = ev;
      if (ev < beta) beta = ev;
      if (beta <= alpha) break;
    }
    return minEval;
  }
}

function getBestMove() {
  const moves = game.moves();
  if (moves.length === 0) return null;

  let depth = 2; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼ˆåˆç´šï¼‰
  
  // æ€è€ƒãƒ¬ãƒ™ãƒ«ã®æ±ºå®š
  if (game.turn() === playerColor) {
     // â˜…è‡ªåˆ†ã®ã‚ªãƒ¼ãƒˆãƒ¢ãƒ¼ãƒ‰æ™‚ã¯å¸¸ã«æœ€å¼·(depth=3)â˜…
     if (isAuto) depth = 3;
  } else {
     // æ•µã®ã‚¿ãƒ¼ãƒ³ã¯è¨­å®šã«å¾“ã†
     if (aiLevel === 2) depth = 3;
     if (aiLevel >= 3) depth = 3; 
  }

  let bestMove = null;
  let bestValue = (game.turn() === 'w') ? -Infinity : Infinity;
  let alpha = -Infinity;
  let beta = Infinity;

  // æ‰‹ã®ä¸¦ã³æ›¿ãˆï¼ˆãƒ©ãƒ³ãƒ€ãƒ æ€§ï¼‹æ•ç²å„ªå…ˆï¼‰
  moves.sort(() => Math.random() - 0.5); 
  moves.sort((a, b) => {
      const sA = (a.indexOf('x') !== -1) ? 10 : 0;
      const sB = (b.indexOf('x') !== -1) ? 10 : 0;
      return sB - sA;
  });

  for (let i = 0; i < moves.length; i++) {
    const move = moves[i];
    game.move(move);
    const value = minimax(game, depth - 1, alpha, beta, game.turn() === 'w');
    game.undo();

    if (game.turn() === 'w') {
      if (value > bestValue) { bestValue = value; bestMove = move; }
      alpha = Math.max(alpha, value);
    } else {
      if (value < bestValue) { bestValue = value; bestMove = move; }
      beta = Math.min(beta, value);
    }
  }
  return bestMove || moves[0];
}

function updateGauge() {
  const score = evaluateBoard(game);
  const percentage = (1 / (1 + Math.exp(-score / 300))) * 100;
  ui.evalWhite.css('width', percentage + '%');
}

// === ã‚²ãƒ¼ãƒ é€²è¡Œ ===
function startGame() {
  initAudio();
  playSound('start');
  aiLevel = parseInt($('#level').val());
  playerColor = $('#color-select').val();
  $('#menu').addClass('hidden');
  
  game.reset();
  isAuto = false;
  clearTimeout(autoTimer);
  
  $('#board').empty(); 
  
  const orient = (playerColor === 'w') ? 'white' : 'black';
  board = Chessboard('board', {
    draggable: true, position: 'start', orientation: orient,
    pieceTheme: pieceTheme, onDragStart: onDragStart, onDrop: onDrop, onSnapEnd: onSnapEnd
  });
  $(window).resize(board.resize);
  updateGauge();
  
  // ãƒœã‚¿ãƒ³ã®çŠ¶æ…‹ã‚’åˆæœŸåŒ–
  ui.btnAuto.text("ğŸ¤– ã‚ªãƒ¼ãƒˆ: OFF").removeClass('btn-auto-active').show();
  ui.btnHint.prop('disabled', false).removeClass('btn-disabled').show();
  ui.btnUndo.prop('disabled', false).removeClass('btn-disabled').show();
  ui.btnRetry.addClass('hidden'); 

  if (playerColor === 'w') {
    ui.face.text(EMOJI_SELF).addClass('active-turn');
    ui.msg.text(getRandomMsg('start'));
    ui.status.text("ã‚ãªãŸã®æ‰‹ç•ª");
  } else {
    ui.face.text(getRandom(EMOJI_ENEMY_NEUTRAL)).addClass('active-turn');
    ui.msg.text(getRandomMsg('start') + " ç§ã‹ã‚‰ã„ãã‚ˆã€œï¼");
    ui.status.text("ç›¸æ‰‹ã®æ‰‹ç•ª");
    board.draggable = false;
    window.setTimeout(makeAiMove, 800);
  }
}

function onDragStart (source, piece) {
  if (game.game_over() || isAuto) return false;
  if (game.turn() !== playerColor) return false;
  if ((playerColor === 'w' && piece.search(/^b/) !== -1) ||
      (playerColor === 'b' && piece.search(/^w/) !== -1)) return false;
      
  const moves = game.moves({ square: source, verbose: true });
  if (moves.length === 0) return false;
  
  removeHighlights();
  moves.forEach(m => {
    const className = m.flags.includes('c') ? 'highlight-capture' : 'highlight-move';
    const squareEl = $('#board .square-' + m.to);
    if(squareEl.length) squareEl.addClass(className);
  });
}

function onDrop (source, target) {
  removeHighlights();
  const move = game.move({ from: source, to: target, promotion: 'q' });
  if (move === null) {
    ui.msg.text(getRandomMsg('badMove'));
    return 'snapback';
  }
  board.position(game.fen());
  if (move.flags.includes('c')) {
      playSound('capture');
      ui.msg.text(getRandomMsg('capture'));
  } else {
      playSound('move');
  }
  
  updateGauge();
  checkGameStatus();
  
  if (!game.game_over() && !isAuto) {
    ui.face.text(getRandom(EMOJI_ENEMY_NEUTRAL)).addClass('active-turn'); 
    ui.status.text("ç›¸æ‰‹ãŒæ€è€ƒä¸­...");
    if(!game.in_check() && Math.random() > 0.6) ui.msg.text(getRandomMsg('aiThink'));
    window.setTimeout(makeAiMove, 100);
  }
}

function onSnapEnd () { board.position(game.fen()); }

function makeAiMove() {
  if (game.game_over()) return;

  if (isAuto || game.turn() !== playerColor) {
      setTimeout(() => {
          const bestMoveSan = getBestMove();
          if (bestMoveSan) {
              const m = game.move(bestMoveSan);
              board.position(game.fen());
              if (m && m.flags.includes('c')) playSound('capture');
              else playSound('move');
          }
          updateGauge();
          checkGameStatus();
          
          if (!game.game_over() && isAuto) {
            autoTimer = setTimeout(makeAiMove, 600); 
          } else if (!isAuto) {
             if (game.turn() === playerColor) {
               board.draggable = true;
             }
          }
      }, 50);
  }
}

// === ã‚²ãƒ¼ãƒ çŠ¶æ…‹ã¨è¡¨æƒ…åˆ¶å¾¡ã®æ›´æ–° ===
function checkGameStatus() {
  const isPlayerTurn = game.turn() === playerColor;
  
  // è©•ä¾¡å€¤å–å¾—ï¼ˆç™½è¦–ç‚¹ï¼‰
  const score = evaluateBoard(game);
  // æ•µã®å„ªå‹¢åº¦ï¼ˆæ•µãŒç™½ãªã‚‰scoreã€æ•µãŒé»’ãªã‚‰-scoreï¼‰
  const enemyAdvantage = (playerColor === 'w') ? -score : score;

  // 1. ã‚²ãƒ¼ãƒ çµ‚äº†åˆ¤å®š
  if (game.game_over()) {
    isAuto = false; clearTimeout(autoTimer);
    ui.btnAuto.hide();
    ui.btnHint.hide();
    ui.btnUndo.hide();
    ui.btnRetry.removeClass('hidden');

    board.draggable = false;
    
    if (game.in_checkmate()) {
      playSound('capture');
      const winner = game.turn() === 'w' ? 'é»’' : 'ç™½';
      const userWon = (winner === 'ç™½' && playerColor === 'w') || (winner === 'é»’' && playerColor === 'b');
      
      if(userWon) {
          ui.face.text("ğŸ˜µ"); // æ•µè² ã‘é¡”
          ui.msg.html(`<span style="color:red;font-weight:bold">ãƒã‚§ãƒƒã‚¯ãƒ¡ã‚¤ãƒˆï¼</span><br>` + getRandomMsg('lose'));
          ui.status.text("ã‚ãªãŸã®å‹ã¡ï¼");
      } else {
          ui.face.text(getRandom(EMOJI_ENEMY_WINNING)); // æ•µå‹ã¡é¡”
          ui.msg.html(`<span style="color:red;font-weight:bold">ãƒã‚§ãƒƒã‚¯ãƒ¡ã‚¤ãƒˆï¼</span><br>` + getRandomMsg('win'));
          ui.status.text("AIã®å‹ã¡ï¼");
      }
    } else {
      ui.face.text("ğŸ¤");
      ui.msg.text(getRandomMsg('draw'));
      ui.status.text("å¼•ãåˆ†ã‘");
    }
    return;
  }
  
  // 2. ç‹æ‰‹åˆ¤å®š
  if (game.in_check()) {
      if (isPlayerTurn) {
          // è‡ªåˆ†ï¼ˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼‰ãŒç‹æ‰‹ã‚’ã‹ã‘ã‚‰ã‚Œã¦ã„ã‚‹
          ui.face.text(EMOJI_SCARED); // â˜…è‡ªåˆ†ãŒç‹æ‰‹ãªã‚‰å¸¸ã«ğŸ˜±
          ui.msg.text(getRandomMsg('check'));
          ui.status.text("ç‹æ‰‹ãŒã‹ã‹ã£ã¦ã„ã¾ã™ï¼");
      } else {
          // æ•µãŒç‹æ‰‹ã‚’ã‹ã‘ã‚‰ã‚Œã¦ã„ã‚‹
          ui.face.text(getRandom(EMOJI_ENEMY_CHECKED));
          ui.status.text("ç›¸æ‰‹ã®æ‰‹ç•ª");
      }
  } else {
      // 3. é€šå¸¸æ™‚
      if (isPlayerTurn) {
          // è‡ªåˆ†ã®ç•ªï¼šã‚¢ã‚¤ã‚³ãƒ³è¨­å®š
          // å„ªå…ˆé †ï¼šç‹æ‰‹(ä¸Šéƒ¨ã§å‡¦ç†æ¸ˆ) > ã‚ªãƒ¼ãƒˆ > é€šå¸¸
          let myFace = isAuto ? EMOJI_ROBOT : EMOJI_SELF;
          ui.face.text(myFace).addClass('active-turn');
          ui.status.text(isAuto ? "ãƒ­ãƒœãƒƒãƒˆæ€è€ƒä¸­(æœ€å¼·)..." : "ã‚ãªãŸã®æ‰‹ç•ª");
          
          if (enemyAdvantage > 300) ui.msg.text(getRandomMsg('winning')); 
          else if (enemyAdvantage < -300) ui.msg.text(getRandomMsg('losing')); 
          else {
              if (isAuto) {
                  if (Math.random() > 0.7) ui.msg.text(getRandomMsg('robotTurn'));
              } else {
                  if (Math.random() > 0.8) ui.msg.text(getRandomMsg('playerTurn'));
              }
          }
      } else {
          // æ•µã®ç•ªï¼šã‚¢ã‚¤ã‚³ãƒ³è¨­å®šï¼ˆå„ªå‹¢åº¦ã§å¤‰åŒ–ï¼‰
          let enemyFace = getRandom(EMOJI_ENEMY_NEUTRAL);
          if (enemyAdvantage > 200) enemyFace = getRandom(EMOJI_ENEMY_WINNING); // æ•µå„ªå‹¢ï¼ãƒ‹ãƒ¤ã‘
          if (enemyAdvantage < -200) enemyFace = getRandom(EMOJI_ENEMY_LOSING); // æ•µåŠ£å‹¢ï¼ç„¦ã‚Š
          
          ui.face.text(enemyFace).addClass('active-turn');
          ui.status.text("ç›¸æ‰‹ã®æ‰‹ç•ª");
      }
  }
}

function toggleAutoPlay() {
  if (game.game_over()) return;
  isAuto = !isAuto;
  
  if (isAuto) {
    removeHighlights();
    ui.btnAuto.text("ğŸ¤– ã‚ªãƒ¼ãƒˆ: ON (æœ€å¼·)").addClass('btn-auto-active');
    ui.btnHint.prop('disabled', true).addClass('btn-disabled');
    ui.btnUndo.prop('disabled', true).addClass('btn-disabled'); 
    
    ui.msg.text("ãˆã£ã€ãƒ­ãƒœãƒƒãƒˆã«ä»»ã›ã‚‹ã®ï¼Ÿ æ¥½ã™ã‚‹æ°—æº€ã€…ã˜ã‚ƒã‚“ï½—");
    
    // é¡”æ›´æ–°ï¼ˆç‹æ‰‹ã•ã‚Œã¦ã„ãªã‘ã‚Œã°ãƒ­ãƒœãƒƒãƒˆé¡”ã¸ï¼‰
    if(!game.in_check() || game.turn() !== playerColor) {
        ui.face.text(game.turn() === playerColor ? EMOJI_ROBOT : getRandom(EMOJI_ENEMY_NEUTRAL));
    }
    if (game.in_check() && game.turn() === playerColor) {
        ui.face.text(EMOJI_SCARED);
    }
    
    board.draggable = false;
    checkGameStatus(); 
    makeAiMove();
  } else {
    ui.btnAuto.text("ğŸ¤– ã‚ªãƒ¼ãƒˆ: OFF").removeClass('btn-auto-active');
    ui.btnHint.prop('disabled', false).removeClass('btn-disabled');
    ui.btnUndo.prop('disabled', false).removeClass('btn-disabled');
    clearTimeout(autoTimer);
    
    if (game.turn() === playerColor) {
      ui.msg.text("ã»ã‚‰ã€ã‚ã‚“ãŸã®ç•ªã ã‚ˆã€‚è‡ªåˆ†ã§ã‚„ã‚Šãªã‚ˆã€‚");
      board.draggable = true;
      // é¡”æ›´æ–°ï¼ˆç‹æ‰‹ã•ã‚Œã¦ã„ãªã‘ã‚Œã°é­”æ³•ä½¿ã„ã¸ï¼‰
      if (!game.in_check()) {
        ui.face.text(EMOJI_SELF).addClass('active-turn');
      } else {
        ui.face.text(EMOJI_SCARED);
      }
      ui.status.text("ã‚ãªãŸã®æ‰‹ç•ª");
    } else {
      ui.msg.text("æ¬¡ã¯ç§ã®ç•ªï¼");
      board.draggable = false;
      // æ•µã®é¡”æ›´æ–°
      checkGameStatus();
      makeAiMove(); 
    }
  }
}

// === å¾…ã£ãŸï¼ˆã‚„ã‚Šç›´ã—ï¼‰ ===
function undoMove() {
  if (isAuto || game.game_over()) return;
  if (game.turn() !== playerColor) return;
  if (game.history().length < 2) return;

  game.undo();
  game.undo();
  
  board.position(game.fen());
  removeHighlights();
  updateGauge();
  
  playSound('move');
  ui.msg.text(getRandomMsg('undo'));
  
  // é¡”æ›´æ–°
  if (game.in_check()) ui.face.text(EMOJI_SCARED);
  else ui.face.text(EMOJI_SELF).addClass('active-turn');
  
  ui.status.text("ã‚ãªãŸã®æ‰‹ç•ª (ã‚„ã‚Šç›´ã—)");
}

function showHint() {
  if (game.game_over() || isAuto) return;
  if (game.turn() !== playerColor) { ui.msg.text("ä»Šã¯ç›¸æ‰‹ã®ç•ªã ã‚ˆï¼ãƒã‚«ãªã®ï¼Ÿ"); return; }

  ui.msg.text("ä»•æ–¹ãªã„ãªãã€ä»Šå›ã ã‘æ•™ãˆã¦ã‚ã’ã‚‹â™¥");
  
  setTimeout(() => {
    // ãƒ’ãƒ³ãƒˆè¨ˆç®—æ™‚ã®ã¿æœ€å¼·ãƒ¬ãƒ™ãƒ«ã§æ¢ç´¢
    const savedLevel = aiLevel;
    aiLevel = 3; 
    const bestMoveSan = getBestMove();
    aiLevel = savedLevel;

    if (!bestMoveSan) { ui.msg.text("ãƒ’ãƒ³ãƒˆãªã—ï¼ è‡ªåˆ†ã§è€ƒãˆãªã‚ˆï½—"); return; }
    
    const moveObj = game.move(bestMoveSan);
    game.undo();

    removeHighlights();
    const sqFrom = $('#board .square-' + moveObj.from);
    const sqTo = $('#board .square-' + moveObj.to);
    if(sqFrom.length) sqFrom.addClass('highlight-hint');
    if(sqTo.length) sqTo.addClass('highlight-hint');
    
    ui.msg.html(`ã»ã‚‰ã€ã“ã“ï¼<br><b>${moveObj.from}</b> â†’ <b>${moveObj.to}</b>ï¼<br>æ„Ÿè¬ã—ã¦ã‚ˆã­â™ª`);
    playSound('move');
  }, 50);
}

function removeHighlights() {
  $('#board [class*="square"]').removeClass('highlight-move highlight-capture highlight-hint');
}
</script>
</body>

</html>


