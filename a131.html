<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
<title>AI Chess - Mesugaki Ultimate (Fixed)</title>

<link rel="stylesheet" href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css">

<style>
  /* === å…¨ä½“è¨­å®š === */
  body {
    margin: 0;
    font-family: 'Helvetica Neue', Arial, sans-serif;
    background: linear-gradient(135deg, #134E5E, #71B280);
    height: 100vh; /* ç”»é¢ã®é«˜ã•ã«å›ºå®š */
    width: 100vw;
    display: flex;
    justify-content: center;
    align-items: center;
    color: #fff;
    overflow: hidden; /* ç”»é¢å…¨ä½“ã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’ç¦æ­¢ */
  }

  /* === ãƒ¡ã‚¤ãƒ³ã®ã‚³ãƒ³ãƒ†ãƒŠãƒœãƒƒã‚¯ã‚¹ === */
  .box {
    background: rgba(255, 255, 255, 0.95);
    color: #333;
    padding: 15px;
    border-radius: 15px;
    box-shadow: 0 20px 50px rgba(0,0,0,0.5);
    display: flex;
    gap: 20px;
    max-width: 950px;
    width: 95%;
    max-height: 98vh; /* ç”»é¢ã‹ã‚‰ã¯ã¿å‡ºã•ãªã„ã‚ˆã†ã«åˆ¶é™ */
    position: relative;
    box-sizing: border-box;
  }

  /* === ç›¤é¢ã‚¨ãƒªã‚¢ === */
  .board-section {
    flex: 2;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
  }
  .board-wrap {
    border: 5px solid #2E7D32;
    border-radius: 4px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.4);
    width: 100%;
    max-width: 60vh; /* ç¸¦ç”»é¢ã§ã‚‚ç›¤é¢ãŒå¤§ãããªã‚Šã™ããªã„ã‚ˆã†ã« */
    aspect-ratio: 1 / 1;
    position: relative;
    transition: box-shadow 0.3s, border-color 0.3s;
    /* â˜…é‡è¦: ã‚¿ãƒƒãƒæ“ä½œæ™‚ã®ãƒ–ãƒ©ã‚¦ã‚¶æ¨™æº–å‹•ä½œï¼ˆã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ç­‰ï¼‰ã‚’ç„¡åŠ¹åŒ– */
    touch-action: none; 
  }
  
  /* ãƒã‚§ã‚¹ãƒœãƒ¼ãƒ‰è‡ªä½“ã®è¨­å®š */
  #board {
    width: 100%;
    height: 100%;
    /* â˜…é‡è¦: ã“ã‚ŒãŒãªã„ã¨ã‚¹ãƒãƒ›ã§ãƒ‰ãƒ©ãƒƒã‚°æ™‚ã«ç”»é¢ãŒå‹•ã */
    touch-action: none; 
  }
    
  /* ç‹æ‰‹ï¼ˆãƒã‚§ãƒƒã‚¯ï¼‰æ™‚ã®èµ¤æ æ¼”å‡º */
  .in-check-danger {
    border-color: #c0392b !important; 
    box-shadow: 0 0 25px rgba(192, 57, 43, 0.8) !important;
  }

  /* === æƒ…å ±ã‚¨ãƒªã‚¢ï¼ˆå³å´ï¼‰ === */
  .info-section {
    flex: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 10px;
    overflow-y: auto; /* ç¸¦ãŒè¶³ã‚Šãªã„å ´åˆã®ã¿å†…éƒ¨ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ« */
  }

  /* === ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã‚¢ã‚¤ã‚³ãƒ³ === */
  .mascot {
    font-size: 50px;
    background: #fff;
    width: 80px;
    height: 80px;
    border-radius: 50%;
    display: flex;
    justify-content: center;
    align-items: center;
    border: 4px solid #ccc;
    margin-bottom: 5px;
    flex-shrink: 0; 
    box-shadow: 0 4px 10px rgba(0,0,0,0.1);
    transition: 0.3s;
  }
    
  .active-turn {
    border-color: #2ecc71 !important;
    box-shadow: 0 0 25px rgba(46, 204, 113, 1.0) !important;
    transform: scale(1.05);
  }

  /* === å½¢å‹¢åˆ¤æ–­ã‚²ãƒ¼ã‚¸ === */
  .eval-gauge-container {
    width: 100%;
    height: 8px;
    background: #555;
    margin-bottom: 10px;
    border-radius: 4px;
    overflow: hidden;
    display: flex;
    flex-shrink: 0;
  }
  .eval-bar-white { height: 100%; background: #2ecc71; width: 50%; transition: width 0.5s ease-out; }
  .eval-bar-black { height: 100%; background: #e74c3c; width: 50%; }

  /* === å¹ãå‡ºã— & ãƒ«ãƒ¼ãƒ« === */
  .bubble {
    position: relative;
    background: #ecf0f1;
    color: #2c3e50;
    border-radius: 12px;
    padding: 10px;
    width: 100%;
    margin-bottom: 10px;
    min-height: 60px; 
    font-size: 13px;
    box-sizing: border-box;
    border: 2px solid #bdc3c7;
    display: flex;
    align-items: center;
    justify-content: center;
    text-align: center;
    font-weight: bold;
    flex-shrink: 0;
  }
  .bubble::after {
    content: '';
    position: absolute;
    top: -12px;
    left: 50%;
    transform: translateX(-50%);
    border: 12px solid transparent;
    border-bottom-color: #bdc3c7;
  }
      
  /* ãƒ«ãƒ¼ãƒ«èª¬æ˜ã‚¨ãƒªã‚¢ */
  .sidebar-rules {
    width: 100%;
    background: #f1f8e9;
    border: 1px solid #c5e1a5;
    border-radius: 8px;
    padding: 8px;
    margin-bottom: 5px;
    font-size: 0.75em;
    color: #33691e;
    box-sizing: border-box;
    text-align: left;
    overflow-y: auto;
    flex-grow: 1; /* ä½™ã£ãŸã‚¹ãƒšãƒ¼ã‚¹ã‚’åŸ‹ã‚ã‚‹ */
    min-height: 0; /* Flexå†…ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ç”¨ */
  }
  .sidebar-rules h4 { margin: 0 0 3px 0; border-bottom: 1px solid #aed581; padding-bottom: 2px; }
  .sidebar-rules ul { margin: 0; padding-left: 15px; }
  .sidebar-rules li { margin-bottom: 2px; }

  /* === ãƒœã‚¿ãƒ³é¡ === */
  .btn-group { 
    width: 100%; 
    display: flex; flex-direction: column; 
    gap: 5px; 
    margin-top: auto; 
    flex-shrink: 0;
  }
  .btn {
    border: none; 
    padding: 10px; 
    border-radius: 6px; 
    font-weight: bold; 
    cursor: pointer; 
    width: 100%; 
    color: white; 
    transition: 0.2s; 
    font-size: 13px;
  }
  .btn-hint { background: #e67e22; } .btn-hint:hover { background: #d35400; }
  .btn-undo { background: #9b59b6; } .btn-undo:hover { background: #8e44ad; } 
  .btn-auto { background: #2ecc71; } .btn-auto:hover { background: #27ae60; }
  .btn-auto-active { background: #e74c3c !important; }
  .btn-retry { background: #3498db; } .btn-retry:hover { background: #2980b9; }
  .btn-reset { background: #95a5a6; } .btn-reset:hover { background: #7f8c8d; }
  .btn-disabled { background: #bdc3c7 !important; cursor: not-allowed; opacity: 0.6; }
  .hidden { display: none !important; }

  /* === ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ï¼ˆãƒ¡ãƒ‹ãƒ¥ãƒ¼ç”»é¢ï¼‰ === */
  .overlay {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(20, 50, 30, 0.98); 
    z-index: 100; 
    display: flex; 
    flex-direction: column; justify-content: center; align-items: center; 
    color: #fff; 
    border-radius: 15px; 
    padding: 20px; 
    box-sizing: border-box;
  }
  .menu-btn {
    background: #2ecc71; color: #fff; font-weight: bold; cursor: pointer; margin-top: 30px;
    padding: 15px 30px; font-size: 18px; border:none; border-radius: 5px; width: 100%;
  }

  /* === ç›¤é¢ã®ãƒã‚¤ãƒ©ã‚¤ãƒˆæ¼”å‡º === */
  .highlight-move { background: radial-gradient(circle, rgba(46, 204, 113, 0.7) 20%, transparent 20%); }
  .highlight-capture { background-color: rgba(231, 76, 60, 0.5) !important; box-shadow: inset 0 0 0 4px rgba(192, 57, 43, 0.9) !important; }
  .highlight-danger-source { 
    background-color: rgba(255, 120, 0, 0.85) !important; 
    box-shadow: inset 0 0 15px rgba(255, 50, 0, 0.8) !important; 
    animation: flash-orange 1.2s infinite alternate;
    z-index: 10; 
  }
  @keyframes flash-orange { from { opacity: 0.8; } to { opacity: 1.0; } }
  .highlight-hint { 
    background: rgba(255, 235, 59, 0.7); 
    box-shadow: inset 0 0 10px rgba(255, 215, 0, 1.0); 
    animation: flash-yellow 0.8s infinite alternate; 
  }
  @keyframes flash-yellow { from { opacity: 0.6; } to { opacity: 1.0; } }

  /* === ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–å¯¾å¿œï¼ˆã‚¹ãƒãƒ›å‘ã‘ï¼‰ === */
  @media(max-width:768px){
    body { 
        padding: 0; 
        align-items: flex-start; /* ä¸Šè©°ã‚ */
    }
    .box { 
        flex-direction: column; 
        height: 100vh; /* ç”»é¢ã„ã£ã±ã„ */
        max-height: 100vh;
        width: 100%; 
        border-radius: 0; 
        padding: 5px; /* ä½™ç™½å‰Šæ¸› */
        margin: 0; 
        gap: 5px;
    }
    
    /* æƒ…å ±ã‚¨ãƒªã‚¢ã‚’ä¸Šã«é…ç½® */
    .info-section { 
        order: -1; 
        width:100%; 
        padding: 2px;
        flex-direction: row; /* æ¨ªä¸¦ã³ã«ã—ã¦çœã‚¹ãƒšãƒ¼ã‚¹åŒ– */
        flex-wrap: wrap;
        justify-content: center;
        gap: 10px;
        flex: 0 0 auto; /* é«˜ã•ã‚’å›ºå®š */
    } 
    
    .mascot { width: 50px; height: 50px; font-size: 30px; margin: 0; }
    .status-wrap { display: flex; flex-direction: column; justify-content: center; flex: 1; }
    .eval-gauge-container { margin-bottom: 5px; height: 6px; }
    #status { font-size: 1em; margin-bottom: 0; text-align: center; }

    /* å¹ãå‡ºã—ã‚’å°ã•ã */
    .bubble { 
        width: 100%; 
        margin: 5px 0; 
        min-height: 40px; 
        padding: 5px; 
        font-size: 12px;
        order: 3; /* ä¸€ç•ªä¸‹ã¸ */
    }
    .bubble::after { display: none; } /* ã—ã£ã½å‰Šé™¤ */

    /* ç›¤é¢ã‚¨ãƒªã‚¢ */
    .board-section { 
        flex: 1; /* æ®‹ã‚Šã®ã‚¹ãƒšãƒ¼ã‚¹ã‚’ä½¿ã† */
        padding: 0;
        justify-content: flex-start;
    }
    /* ç›¤é¢ã‚µã‚¤ã‚ºèª¿æ•´ï¼šç”»é¢å¹…ã«åˆã‚ã›ã¦æ­£æ–¹å½¢ã‚’ç¶­æŒ */
    .board-wrap { 
        width: 100%; 
        max-width: 95vw; /* ç”»é¢å¹…ã®95% */
        height: auto; 
        aspect-ratio: 1/1; 
    }
    
    /* ã‚¹ãƒãƒ›ã§ã¯ãƒ«ãƒ¼ãƒ«èª¬æ˜ã‚’å®Œå…¨ã«éš ã™ï¼ˆã‚¹ãƒšãƒ¼ã‚¹ç¢ºä¿ï¼‰ */
    .sidebar-rules { display: none; }
    
    /* ãƒœã‚¿ãƒ³ã‚¨ãƒªã‚¢ */
    .btn-group {
        flex-direction: row; /* æ¨ªä¸¦ã³ */
        flex-wrap: wrap;
    }
    .btn { width: 48%; font-size: 11px; padding: 8px; flex: 1; }
  }
</style>
</head>
<body>

<div class="box">
  <div id="menu" class="overlay">
    <div style="width:100%; max-width:400px; text-align:center;">
      <h1 style="font-size:2.5em; margin:0 0 20px 0;">â™š AI Chess</h1>
      <a href="a10.html">Ver.0.1.0ã¸</a><a href="a115.html">Ver.1.1.5ã¸</a>
      <div style="display:flex; gap:20px; width:100%;">
        <div style="flex:1;">
          <p style="font-weight:bold;">è‰²</p>
          <select id="color-select" style="width:100%; padding:8px;">
              <option value="w">â™” å…ˆæ‰‹ (ç™½)</option>
              <option value="b">â™š å¾Œæ‰‹ (é»’)</option>
          </select>
        </div>
        <div style="flex:1;">
          <p style="font-weight:bold;">ãƒ¬ãƒ™ãƒ«</p>
          <select id="level" style="width:100%; padding:8px;">
            <option value="1">ğŸŒ± å…¥é–€ (é›‘é­š)</option>
            <option value="2">ğŸŒ² ä¸­ç´š (æ™®é€š)</option>
            <option value="3" selected>ğŸ‰ è¶…ç´š (æœ€å¼·)</option>
          </select>
        </div>
      </div>
      <button class="menu-btn" onclick="startGame()">ğŸ® ã‚²ãƒ¼ãƒ ã‚¹ã‚¿ãƒ¼ãƒˆï¼</button>
    </div>
  </div>

  <div class="board-section">
    <div class="board-wrap">
        <div id="board"></div>
    </div>
  </div>

  <div class="info-section">
    <div class="mascot" id="face">ğŸ˜</div>
    
    <div class="status-wrap" style="width: 100%; max-width: 300px;">
        <div class="eval-gauge-container">
            <div id="eval-bar-white" class="eval-bar-white"></div>
            <div id="eval-bar-black" class="eval-bar-black" style="background:#555; width:0;"></div>
        </div>
        <div id="status" style="font-weight:bold; font-size: 1.2em;">æº–å‚™ä¸­...</div>
    </div>

    <div class="bubble" id="msg">è¨­å®šã‚’é¸ã‚“ã§ã‚¹ã‚¿ãƒ¼ãƒˆã—ã¦ã­ï¼</div>
    
    <div class="sidebar-rules">
        <h4>ğŸ“œ ã–ã“ã–ã“ãƒ«ãƒ¼ãƒ«</h4>
        <ul>
            <li>ç‹æ§˜(ã‚­ãƒ³ã‚°)ã‚’è©°ã¾ã›ã°å‹ã¡â™¥</li>
            <li>é§’ã¯ãƒ‰ãƒ©ãƒƒã‚°ã§å‹•ã‹ã—ã¦ã­ã€‚</li>
        </ul>
        <div style="font-size:0.9em; margin-top:5px; line-height:1.4;">
            <b>â™™ãƒãƒ¼ãƒ³</b>: å‰1æ­©ã€‚æ•µã¯æ–œã‚ã€‚<br>
            <b>â™˜ãƒŠã‚¤ãƒˆ</b>: Lå­—ã‚¸ãƒ£ãƒ³ãƒ—ã€‚<br>
            <b>â™—ãƒ“ã‚·ãƒ§ãƒƒãƒ—</b>: æ–œã‚ã€‚<br>
            <b>â™–ãƒ«ãƒ¼ã‚¯</b>: ç¸¦æ¨ªã€‚<br>
            <b>â™•ã‚¯ã‚¤ãƒ¼ãƒ³</b>: ç¸¦æ¨ªæ–œã‚ã€‚<br>
            <b>â™”ã‚­ãƒ³ã‚°</b>: å‘¨å›²1æ­©ã€‚
        </div>
    </div>

    <div class="btn-group">
      <button class="btn btn-hint" id="btn-hint" onclick="showHint()">ğŸ’¡ ãƒ’ãƒ³ãƒˆ</button>
      <button class="btn btn-undo" id="btn-undo" onclick="undoMove()">â†©ï¸ å¾…ã£ãŸ</button>
      <button class="btn btn-auto" id="btn-auto" onclick="toggleAutoPlay()">ğŸ¤– ã‚ªãƒ¼ãƒˆ</button>
      <button class="btn btn-retry hidden" id="btn-retry" onclick="startGame()">ğŸ”„ å†æˆ¦</button>
      <button class="btn btn-reset" onclick="location.reload()">ğŸ  æˆ»ã‚‹</button>
    </div>
  </div>
</div>

<script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
<script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>

<script>
// === ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°å®šç¾© ===
const game = new Chess();
let board = null;
let aiLevel = 3; 
let isAuto = false;
let autoTimer = null;
let playerColor = 'w';
let audioCtx = null;
let currentDragHover = null; 

// â˜…æ”¹ä¿®: ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã®é‡ã„å‡¦ç†ã‚’è»½æ¸›ã™ã‚‹ãŸã‚ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥
let dragSimGame = null;

// === ãƒ¡ã‚¹ã‚¬ã‚­ãƒ»ã‚­ãƒ£ãƒ©å®šç¾© ===
const EMOJI_SELF = "ğŸ§™â€â™‚ï¸"; 
const EMOJI_ROBOT = "ğŸ¤–"; 
const EMOJI_SCARED = "ğŸ˜±"; 
const EMOJI_ENEMY_NORMAL = ["ğŸ˜", "ğŸ¥´", "ğŸ˜—"];
const EMOJI_ENEMY_THINK = ["ğŸ¤”", "ğŸ¤¨", "ğŸ˜¶"]; 
const EMOJI_ENEMY_WIN = ["ğŸ˜†", "ğŸ¤£", "ğŸ˜ˆ", "ğŸ¤ª"];
const EMOJI_ENEMY_LOSE = ["ğŸ˜­", "ğŸ˜¡", "ğŸ¤¯", "ğŸ¤¢"];
const EMOJI_ENEMY_CHECK = ["ğŸ¤­", "ğŸ˜", "ğŸ”ª"];

const ui = { 
  face: $('#face'), msg: $('#msg'), status: $('#status'), 
  btnAuto: $('#btn-auto'), btnHint: $('#btn-hint'), btnUndo: $('#btn-undo'), btnRetry: $('#btn-retry'), 
  evalWhite: $('#eval-bar-white'), boardWrap: $('.board-wrap') 
};

const pieceNames = { p: "ãƒãƒ¼ãƒ³", n: "ãƒŠã‚¤ãƒˆ", b: "ãƒ“ã‚·ãƒ§ãƒƒãƒ—", r: "ãƒ«ãƒ¼ã‚¯", q: "ã‚¯ã‚¤ãƒ¼ãƒ³", k: "ã‚­ãƒ³ã‚°" };

const msgDict = {
  start: ["ã¸ã‡ã€ç§ã«æŒ‘ã‚€ã‚“ã ï¼Ÿ 100å¹´æ—©ã„ã‚“ã˜ã‚ƒãªã„ï¼Ÿ", "é›‘é­šç‹©ã‚Šã®æ™‚é–“ã ã€œâ™¥", "æ‰‹åŠ æ¸›ãªã—ã§ãƒœã‚³ãƒœã‚³ã«ã—ã¦ã‚ã’ã‚‹â™ª"],
  invalidMove: ["ã¯ï¼Ÿ ãã“ã¯ãƒ«ãƒ¼ãƒ«é•åã ã£ã¦ã°ï½—", "ãƒ«ãƒ¼ãƒ«ã‚‚çŸ¥ã‚‰ãªã„ã®ï¼Ÿ ã–ãƒ¼ã“â™¥", "ã¡ã‚ƒã‚“ã¨é§’ã®å‹•ãè¦šãˆãªã‚ˆã€œ"],
  ignoreCheck: ["ãƒã€œã‚«ï¼ ç‹æ§˜å–ã‚‰ã‚Œã¡ã‚ƒã†ã‚ˆï¼Ÿ", "ç‹æ‰‹ã‹ã‹ã£ã¦ã‚‹ã®ï¼ ç›®ã¤ã„ã¦ã‚‹ï¼Ÿ", "è² ã‘ãŸã„ã®ã‹ãªï¼Ÿï½—"],
  captureByPlayer: (p) => [`ã‚ãƒ¼ã‚ã€${p}ãŒå–ã‚‰ã‚Œã¡ã‚ƒã£ãŸ...`, `ãµã‚“ã€${p}ãã‚‰ã„ãã‚Œã¦ã‚„ã‚‹ã‚ˆã€‚`, `èª¿å­ã«ä¹—ã‚‰ãªã„ã§ã‚ˆã­ã€ãŸã‹ãŒ${p}ã ã—ï¼`],
  captureByEnemy: (p) => [`ã„ãŸã ãã€œâ™¥ ã‚ã‚“ãŸã®${p}ã€å¼±ã™ãï½—`, `ä¸ç”¨å¿ƒã ã­ã‡ã€œï½— ${p}ã¯æ²¡åï¼`, `ã‚ã€œã‚ã€${p}æ¸›ã£ã¡ã‚ƒã£ãŸï½— ã–ã¾ã‚ï½—`],
  checkByPlayer: ["ã†ã£...ç”Ÿæ„æ°—ãªï¼", "ãã¬ã¬...ã¾ã è©°ã¾ãªã„ã—ï¼", "ã¡ã‚‡ã£ã¨ï¼ ã³ã£ãã‚Šã™ã‚‹ã˜ã‚ƒã‚“ï¼"],
  checkByEnemy: ["ç‹æ‰‹ã€œâ™ª æ°—ã¥ã„ã¦ãŸï¼Ÿï½—", "ã»ã‚‰ã»ã‚‰ã€é€ƒã’ãªã„ã¨çµ‚ã‚ã£ã¡ã‚ƒã†ã‚ˆï¼Ÿ", "æ¬¡ã§çµ‚ã‚ã‚Šã‹ã‚‚ã­ã€œâ™¥"],
  moveByPlayer_Even: ["ãµãƒ¼ã‚“ã€ãã†å‹•ãã‚“ã ã€‚", "ã¸ã‡...æ‚ªããªã„ã‹ã‚‚ï¼Ÿ", "ã‚‚ã£ã¨ã„ã„æ‰‹ã‚ã£ãŸã‚“ã˜ã‚ƒãªã„ï¼Ÿï½—", "å¿…æ­»ã ã­ã‡ã€œï½—"],
  moveByPlayer_AiWinning: ["ç„¡é§„ãªæŠµæŠ—ã”è‹¦åŠ´ã•ã¾ã€œï½—", "ã­ãˆã€ã¾ã ç¶šã‘ã‚‹ã®ï¼Ÿ æ—©ãé™å‚ã—ãªã‚ˆï½—", "ãã®æ‰‹ã€ä½•ã®æ„å‘³ãŒã‚ã‚‹ã®ï¼Ÿ", "ã‚ãŒã‘ã°ã‚ãŒãã»ã©æƒ¨ã‚ã ã­ã‡ï½—"],
  moveByPlayer_AiLosing: ["ãã¬ã¬â€¦èª¿å­ä¹—ã‚‹ãªã‚ˆï¼Ÿ", "ã¾ã€ã¾ãã‚Œã§ã—ã‚‡ã€ã¾ãã‚Œï¼", "ã†ã–â€¦ãªã‚“ã§ãã‚“ãªæ‰‹ãŒè¦‹ãˆã‚‹ã‚ã‘ï¼Ÿ", "ãã£â€¦ã¾ã è² ã‘ã¦ãªã„ã—ï¼"],
  moveByEnemy_Even: ["ã“ã‚Œãªã‚‰ã©ã†ï¼Ÿ", "ç§ã®ã‚¿ãƒ¼ãƒ³ï¼", "ã“ã‚Œã§ã‚¤ãƒã‚³ãƒ­ã ã‚ˆâ™ª", "è¨ˆç®—é€šã‚Šã ã—ã€œ"],
  moveByEnemy_AiWinning: ["ã¯ã„ã€ã“ã‚Œã§è©°ã¿ã˜ã‚ƒãªã„ï¼Ÿï½—", "ã‚‚ã†çµ‚ã‚ã‚ŠãŒè¦‹ãˆã¦ããŸã­ã€œ", "çµ¶æœ›ã—ãªã•ã„â™ª", "å¼±ã„å¼±ã„ã€å¼±ã™ãã‚‹ã‚ˆã€œï½—"],
  moveByEnemy_AiLosing: ["ã¾ã â€¦ã¾ã é€†è»¢ã§ãã‚‹ã—â€¦ï¼", "æœ¬æ°—å‡ºã™ã‹ã‚‰è¦šæ‚Ÿã—ãªã•ã„ã‚ˆï¼", "ã†ã…â€¦ãªã‚“ã§ã“ã†ãªã‚‹ã®â€¦", "è«¦ã‚ãªã„ã‚‚ã‚“ï¼"],
  win: ["ã¯ã„ç§ã®å‹ã¡ã€œï¼ å¼±ã™ãï½—", "ã–ã€œã“â™¥ ã–ã€œã“â™¥", "å‡ºç›´ã—ã¦ããªã•ã„ï¼"],
  lose: ["ã†ã...è² ã‘ãŸ...ï¼Ÿ", "ãã¬ã¬...æ¬¡ã¯çµ¶å¯¾å‹ã¤ã‹ã‚‰ï¼", "è¦šãˆã¨ããªã•ã„ã‚ˆï¼"],
  draw: ["ã¡ã£ã€å¼•ãåˆ†ã‘ã‹...", "é€ƒã’åˆ‡ã£ãŸã¤ã‚‚ã‚Šï¼Ÿ", "ã¤ã¾ã‚“ãªã„ã®ãƒ¼"],
  autoOn: ["ã¯ï¼Ÿ ãƒ­ãƒœãƒƒãƒˆã«é ¼ã‚‹ã®ï¼Ÿ ãƒ€ãƒƒã‚µï½—", "è‡ªåˆ†ã§å‹ã¦ãªã„ã‹ã‚‰ã£ã¦æ©Ÿæ¢°é ¼ã‚Šï¼Ÿ", "ãƒ—ãƒ©ã‚¤ãƒ‰ãªã„ã®ã€œï¼Ÿ ã–ãƒ¼ã“ï½—"],
  autoResumeMe: ["ã‚ã‚Œï¼Ÿ ãƒ­ãƒœãƒƒãƒˆãã‚“ã‚¯ãƒ“ï¼Ÿï½—", "ã»ã‚‰ã€è‡ªåˆ†ã®ç•ªã ã‚ˆï¼Ÿ é€ƒã’ãªã„ã§ã‚ˆã­ï¼", "ã‚„ã£ã¨è‡ªåˆ†ã§ã‚„ã‚‹æ°—ã«ãªã£ãŸï¼Ÿ"],
  autoResumeEnemy: ["ç›¸æ‰‹ï¼ˆç§ï¼‰ãŒè€ƒãˆã¦ã‚‹é€”ä¸­ã ã‹ã‚‰ã¡ã‚‡ã£ã¨å¾…ã£ã¦ãªã•ã„ã‚ˆã€‚", "ãƒ­ãƒœãƒƒãƒˆãã‚“å¾…æ©Ÿä¸­ã€œã€‚", "ã‚ã€é€ƒã’ãŸï½—"],
  hint: ["ã»ã‚‰ã€ã“ã“å‹•ã‹ã›ã°ï¼Ÿ ç‰¹åˆ¥ã‚µãƒ¼ãƒ“ã‚¹ã ã‹ã‚‰ã­ï¼", "ã—ã‚‡ã†ãŒãªã„ãªã...ä»Šå›ã ã‘ã ã‚ˆï¼Ÿ", "ã“ã‚“ãªæ‰‹ã‚‚è¦‹ãˆãªã„ã®ï¼Ÿ è¦–é‡ç‹­ã™ãï½—"],
  undo: ["å¾…ã£ãŸï¼Ÿ å¾€ç”Ÿéš›ãŒæ‚ªã„ãªã...", "ãˆãƒ¼ã€ãšã‚‹ããªã„ï¼Ÿ ã¾ã€ã„ã„ã‘ã©ï½—", "ã¯ã„ã¯ã„ã€è¦‹ãªã‹ã£ãŸã“ã¨ã«ã—ã¦ã‚ã’ã‚‹ã€‚"]
};

function getRandom(arr) { return arr[Math.floor(Math.random() * arr.length)]; }
function getRandomMsg(cat, param) { 
    const entry = msgDict[cat];
    if (typeof entry === 'function') return getRandom(entry(param));
    return getRandom(entry || ["..."]); 
}

function initAudio() { if(!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)(); if(audioCtx.state==='suspended') audioCtx.resume(); }
function playSound(type) {
  if(!audioCtx) return;
  const t = audioCtx.currentTime;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  
  if (type === 'move') {
    osc.frequency.setValueAtTime(180, t); osc.frequency.exponentialRampToValueAtTime(40, t+0.12);
    gain.gain.setValueAtTime(0.4, t); gain.gain.exponentialRampToValueAtTime(0.01, t+0.12);
    osc.start(t); osc.stop(t+0.12);
  } else if (type === 'capture') {
    osc.type = 'triangle'; osc.frequency.setValueAtTime(350, t); osc.frequency.exponentialRampToValueAtTime(60, t+0.15);
    gain.gain.setValueAtTime(0.4, t); gain.gain.exponentialRampToValueAtTime(0.01, t+0.15);
    osc.start(t); osc.stop(t+0.15);
  } else if (type === 'start') {
    osc.frequency.setValueAtTime(440, t); osc.frequency.linearRampToValueAtTime(880, t+0.3);
    gain.gain.setValueAtTime(0.1, t); gain.gain.linearRampToValueAtTime(0, t+0.5);
    osc.start(t); osc.stop(t+0.5);
  }
}

// === AIé–¢é€£ ===
const PST={
    p:[0,0,0,0,0,0,0,0,50,50,50,50,50,50,50,50,10,10,20,30,30,20,10,10,5,5,10,25,25,10,5,5,0,0,0,20,20,0,0,0,5,-5,-10,0,0,-10,-5,5,5,10,10,-20,-20,10,10,5,0,0,0,0,0,0,0,0],
    n:[-50,-40,-30,-30,-30,-30,-40,-50,-40,-20,0,0,0,0,-20,-40,-30,0,10,15,15,10,0,-30,-30,5,15,20,20,15,5,-30,-30,0,15,20,20,15,0,-30,-30,5,10,15,15,10,5,-30,-40,-20,0,5,5,0,-20,-40,-50,-40,-30,-30,-30,-30,-40,-50],
    b:[-20,-10,-10,-10,-10,-10,-10,-20,-10,0,0,0,0,0,0,-10,-10,0,5,10,10,5,0,-10,-10,5,5,10,10,5,5,-10,-10,0,10,10,10,10,0,-10,-10,10,10,10,10,10,10,-10,-10,5,0,0,0,0,5,-10,-20,-10,-10,-10,-10,-10,-10,-20],
    r:[0,0,0,0,0,0,0,0,5,10,10,10,10,10,10,5,-5,0,0,0,0,0,0,-5,-5,0,0,0,0,0,0,-5,-5,0,0,0,0,0,0,-5,-5,0,0,0,0,0,0,-5,-5,0,0,0,0,0,0,-5,0,0,0,5,5,0,0,0],
    q:[-20,-10,-10,-5,-5,-10,-10,-20,-10,0,0,0,0,0,0,-10,-10,0,5,5,5,5,0,-10,-5,0,5,5,5,5,0,-5,0,0,5,5,5,5,0,-5,-10,5,5,5,5,5,0,-10,-10,0,5,0,0,0,0,-10,-20,-10,-10,-5,-5,-10,-10,-20],
    k:[-30,-40,-40,-50,-50,-40,-40,-30,-30,-40,-40,-50,-50,-40,-40,-30,-30,-40,-40,-50,-50,-40,-40,-30,-30,-40,-40,-50,-50,-40,-40,-30,-20,-30,-30,-40,-40,-30,-30,-20,-10,-20,-20,-20,-20,-20,-20,-10,20,20,0,0,0,0,20,20,20,30,10,0,0,10,30,20]
};
const VAL={p:100,n:320,b:330,r:500,q:900,k:20000};

function getBoardValue(g) {
  let v = 0; const b = g.board();
  for(let r=0; r<8; r++) for(let c=0; c<8; c++) {
    const p = b[r][c];
    if(p) {
      let score = VAL[p.type] + (PST[p.type][p.color==='w'?(r*8+c):((7-r)*8+c)]||0);
      v += (p.color==='w' ? score : -score);
    }
  }
  return v;
}

function orderMoves(moves) {
  return moves.sort((a,b)=>{
    let sA=0,sB=0;
    if(a.flags.includes('c')) sA+=10+(VAL[a.captured]||0)-(VAL[a.piece]||0)/10;
    if(a.flags.includes('p')) sA+=100;
    if(b.flags.includes('c')) sB+=10+(VAL[b.captured]||0)-(VAL[b.piece]||0)/10;
    if(b.flags.includes('p')) sB+=100;
    return sB-sA;
  });
}

function minimax(g, depth, alpha, beta, isMax) {
  if (depth===0 || g.game_over()) return getBoardValue(g);
  let moves = orderMoves(g.moves({ verbose: true }));
  if(moves.length === 0) return getBoardValue(g);
  
  if (isMax) {
    let maxEval = -Infinity;
    for (let m of moves) {
      g.move(m); 
      let eval = minimax(g, depth-1, alpha, beta, false); 
      g.undo();
      maxEval = Math.max(maxEval, eval); 
      alpha = Math.max(alpha, eval);
      if (beta <= alpha) break;
    }
    return maxEval;
  } else {
    let minEval = Infinity;
    for (let m of moves) {
      g.move(m); 
      let eval = minimax(g, depth-1, alpha, beta, true); 
      g.undo();
      minEval = Math.min(minEval, eval); 
      beta = Math.min(beta, eval);
      if (beta <= alpha) break;
    }
    return minEval;
  }
}

function getBestMove(levelOverride) {
  const currentLevel = levelOverride || aiLevel;
  const moves = game.moves({ verbose: true });
  if (!moves.length) return null;
  
  if (currentLevel === 1) {
    if(Math.random()<0.5) return getRandom(moves);
    const captures = moves.filter(m => m.flags.includes('c'));
    return captures.length ? getRandom(captures) : getRandom(moves);
  }
  
  const depth = (currentLevel === 2) ? 2 : 3;
  const isWhite = (game.turn() === 'w');
  let bestMove = null; 
  let bestVal = isWhite ? -Infinity : Infinity;
  const orderedMoves = orderMoves(moves);
  
  for(let m of orderedMoves) {
    game.move(m);
    let val = minimax(game, depth - 1, -Infinity, Infinity, !isWhite);
    game.undo();
    if(isWhite) { if(val > bestVal) { bestVal = val; bestMove = m; } }
    else { if(val < bestVal) { bestVal = val; bestMove = m; } }
  }
  return bestMove || getRandom(moves);
}

// === ã‚²ãƒ¼ãƒ é€²è¡Œãƒ­ã‚¸ãƒƒã‚¯ ===
function startGame() {
  initAudio(); playSound('start');
  playerColor = $('#color-select').val();
  aiLevel = parseInt($('#level').val());
  $('#menu').addClass('hidden');
  game.reset(); 
  isAuto = false; 
  clearTimeout(autoTimer);
  $('#board').empty();
  
  const orient = playerColor==='w'?'white':'black';
  const pieceTheme = p => {
    const c = p[0]==='w'?'#fff':'#000', s = p[0]==='w'?'#000':'#fff';
    const sym = {'P':'â™™','N':'â™˜','B':'â™—','R':'â™–','Q':'â™•','K':'â™”','p':'â™Ÿ','n':'â™','b':'â™','r':'â™œ','q':'â™›','k':'â™š'};
    return 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 60 60"><text x="50%" y="58%" text-anchor="middle" dominant-baseline="middle" font-family="sans-serif" font-size="50" fill="${c}" stroke="${s}" stroke-width="1.5">${sym[p[1]]||'?'}</text></svg>`);
  };

  board = Chessboard('board', {
    draggable: true, 
    position: 'start', 
    orientation: orient, 
    pieceTheme: pieceTheme,
    onDragStart: onDragStart, 
    onDragMove: onDragMove, 
    onDrop: onDrop, 
    onSnapEnd: onSnapEnd
  });
  
  $(window).resize(board.resize);
  ui.msg.text(getRandomMsg('start'));
  ui.btnAuto.removeClass('btn-auto-active').text("ğŸ¤– ã‚ªãƒ¼ãƒˆ: OFF");
  updateStatus();
  gameLoop();
}

function gameLoop() {
  clearTimeout(autoTimer);
  if(game.game_over()) return;

  const myTurn = (game.turn() === playerColor);
  if (myTurn && !isAuto) return;
  
  autoTimer = setTimeout(() => {
    makeAiMove();
  }, 600);
}

function makeAiMove() {
  if (game.game_over()) return;

  const turnColor = game.turn();
  const isEnemy = (turnColor !== playerColor);
  const useLevel = isEnemy ? aiLevel : 3;
  
  const m = getBestMove(useLevel);
  if (m) {
    const moveResult = game.move(m);
    board.position(game.fen());
    playSound(moveResult.flags.includes('c') ? 'capture' : 'move');
    updateTurnMessage(moveResult, false); 
    updateStatus();
    gameLoop(); 
  }
}

// === ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ“ä½œã‚¤ãƒ™ãƒ³ãƒˆ ===
function onDragStart(source, piece) {
  if (game.game_over() || isAuto) return false;
  if (game.turn() !== playerColor) return false;
  if ((playerColor === 'w' && piece.search(/^b/) !== -1) || (playerColor === 'b' && piece.search(/^w/) !== -1)) return false;
  
  const moves = game.moves({ square: source, verbose: true });
  if (moves.length === 0) return false;

  // â˜…è»½é‡åŒ–: ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹æ™‚ã«ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ã®ã‚²ãƒ¼ãƒ ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä¸€åº¦ã ã‘ä½œæˆ
  dragSimGame = new Chess(game.fen());

  removeHighlights();
  moves.forEach(m => {
    $('#board .square-' + m.to).addClass(m.flags.includes('c') ? 'highlight-capture' : 'highlight-move');
  });
}

function onDragMove(newLocation, oldLocation, source, piece) {
  if (newLocation === currentDragHover) return; 
  currentDragHover = newLocation;
  
  // â˜…è»½é‡åŒ–: å…·ä½“çš„ãªã‚¯ãƒ©ã‚¹åã‚’æŒ‡å®šã›ãšã«å‰Šé™¤
  $('#board .highlight-danger-source').removeClass('highlight-danger-source');
  
  if (newLocation === 'offboard') return;

  // â˜…è»½é‡åŒ–: æ¯å› new Chess() ã›ãšã«ã€dragSimGame ã‚’å†åˆ©ç”¨ï¼ˆçŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆï¼‰
  // chess.jsã®load()ã¯new Chess()ã‚ˆã‚Šå°‘ã—è»½ã„ãŒã€é »ç¹ãªç”Ÿæˆã¯é¿ã‘ã‚‹
  // ã“ã“ã§ã¯ logic ã®é‡ã•ãŒä¸»åŸå› ã«ãªã‚Šã†ã‚‹ãŸã‚ã€ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã¯æ…é‡ã«
  // ãŸã ã€ä¸€ç•ªã®ã€Œã‚«ã‚¯ã¤ãã€åŸå› ã¯ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚¤ãƒ™ãƒ³ãƒˆã¨ã®ç«¶åˆãªã®ã§ã€touch-action:noneã§ã»ã¼è§£æ±ºã™ã‚‹
  
  // å®‰å…¨ã®ãŸã‚ãƒªã‚»ãƒƒãƒˆã—ã¦ã‹ã‚‰ä½¿ã†
  dragSimGame.load(game.fen());

  const move = dragSimGame.move({ from: source, to: newLocation, promotion: 'q' });
  if (move) {
      const enemyMoves = dragSimGame.moves({ verbose: true });
      const attackers = enemyMoves.filter(m => m.to === newLocation);
      if (attackers.length > 0) {
        attackers.forEach(m => $('#board .square-' + m.from).addClass('highlight-danger-source'));
      }
  }
}

function onDrop(source, target) {
  removeHighlights();
  $('.highlight-danger-source').removeClass('highlight-danger-source');
  
  const wasInCheck = game.in_check();
  const move = game.move({ from: source, to: target, promotion: 'q' });

  if (move === null) {
    if (wasInCheck) ui.msg.text(getRandomMsg('ignoreCheck')); 
    else ui.msg.text(getRandomMsg('invalidMove')); 
    return 'snapback'; 
  }

  playSound(move.flags.includes('c') ? 'capture' : 'move');
  updateTurnMessage(move, true);
  updateStatus();
  gameLoop();
}

function onSnapEnd() { board.position(game.fen()); }

function updateTurnMessage(move, isPlayerMove) {
    if (game.game_over()) return; 

    if (game.in_check()) {
        ui.msg.text(isPlayerMove ? getRandomMsg('checkByPlayer') : getRandomMsg('checkByEnemy'));
        return;
    }

    if (move.flags.includes('c')) {
        const pieceName = pieceNames[move.captured] || "é§’";
        ui.msg.text(isPlayerMove ? getRandomMsg('captureByPlayer', pieceName) : getRandomMsg('captureByEnemy', pieceName));
        return;
    }

    const rawScore = getBoardValue(game);
    const aiAdvantage = (playerColor === 'w') ? -rawScore : rawScore;
    let situationSuffix = "_Even";
    if (aiAdvantage > 300) situationSuffix = "_AiWinning";
    else if (aiAdvantage < -300) situationSuffix = "_AiLosing";

    const msgKey = (isPlayerMove ? "moveByPlayer" : "moveByEnemy") + situationSuffix;
    ui.msg.text(getRandomMsg(msgKey));
}

function updateStatus() {
  const score = getBoardValue(game);
  const pct = (1 / (1 + Math.exp(-score / 500))) * 100;
  ui.evalWhite.css('width', pct + '%');
  
  const isMyTurn = (game.turn() === playerColor);
  if (isMyTurn) ui.face.addClass('active-turn');
  else ui.face.removeClass('active-turn');
  
  ui.status.text(isMyTurn ? "ã‚ãªãŸã®ç•ª" : "ç›¸æ‰‹ã®ç•ª");
  if(board) board.draggable = (isMyTurn && !isAuto && !game.game_over());

  if(game.game_over()) {
    ui.btnRetry.removeClass('hidden'); ui.btnAuto.hide(); ui.btnHint.hide(); ui.btnUndo.hide(); ui.status.text("æ±ºç€ï¼");
    if(game.in_checkmate()) {
        const iWon = (game.turn()==='b' && playerColor==='w') || (game.turn()==='w' && playerColor==='b');
        ui.msg.html(iWon ? getRandomMsg('win') : getRandomMsg('lose'));
        ui.face.text(iWon ? getRandom(EMOJI_ENEMY_LOSE) : getRandom(EMOJI_ENEMY_WIN));
    } else {
        ui.msg.text(getRandomMsg('draw'));
        ui.face.text(getRandom(EMOJI_ENEMY_NORMAL));
    }
    return;
  }
  
  if(game.in_check()) {
    if(isMyTurn) { 
       ui.face.text(EMOJI_SCARED);
       ui.boardWrap.addClass('in-check-danger');
    } else { 
       ui.face.text(getRandom(EMOJI_ENEMY_CHECK));
       ui.boardWrap.addClass('in-check-danger');
    }
  } 
  else {
    ui.boardWrap.removeClass('in-check-danger');
    if(isMyTurn) {
       ui.face.text(isAuto ? EMOJI_ROBOT : EMOJI_SELF);
    } else {
       ui.face.text(getRandom(EMOJI_ENEMY_THINK)); 
    }
  }
}

function toggleAutoPlay() {
  if(game.game_over()) return;
  isAuto = !isAuto;
  
  if(isAuto) {
    removeHighlights();
    ui.btnHint.prop('disabled', true).addClass('btn-disabled');
    ui.btnUndo.prop('disabled', true).addClass('btn-disabled');
    ui.btnAuto.addClass('btn-auto-active').text("ğŸ¤– ON");
    ui.msg.text(getRandomMsg('autoOn'));
    gameLoop();
  } else {
    ui.btnHint.prop('disabled', false).removeClass('btn-disabled');
    ui.btnUndo.prop('disabled', false).removeClass('btn-disabled');
    ui.btnAuto.removeClass('btn-auto-active').text("ğŸ¤– OFF");
    clearTimeout(autoTimer);
    if (game.turn() === playerColor) {
        ui.msg.text(getRandomMsg('autoResumeMe'));
    } else {
        ui.msg.text(getRandomMsg('autoResumeEnemy'));
    }
    if(game.turn() !== playerColor) {
       gameLoop(); 
    }
    updateStatus();
  }
}

function undoMove() {
  if(!isAuto && !game.game_over() && game.turn()===playerColor && game.history().length>=2) {
    game.undo(); game.undo(); 
    board.position(game.fen()); 
    removeHighlights();
    $('.highlight-danger-source').removeClass('highlight-danger-source'); 
    ui.msg.text(getRandomMsg('undo')); 
    updateStatus();
  }
}

function showHint() {
  if(game.turn()!==playerColor || isAuto) return;
  ui.msg.text("ãƒ’ãƒ³ãƒˆï¼Ÿ ã—ã‚‡ã†ãŒãªã„ãªã...");
  setTimeout(() => {
      const m = getBestMove(3); 
      if(m) {
          const obj = game.move(m); game.undo();
          $('#board .square-'+obj.from).addClass('highlight-hint');
          $('#board .square-'+obj.to).addClass('highlight-hint');
          ui.msg.text(getRandomMsg('hint'));
      }
  }, 100);
}

function removeHighlights() {
  $('#board [class*="square"]').removeClass('highlight-move highlight-capture highlight-hint');
}
</script>
</body>
</html>