<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
<title>AI Chess - Mesugaki Ultimate (Wakarase Edition)</title>

<link rel="stylesheet" href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css">

<style>
  /* === å…¨ä½“è¨­å®š === */
  body {
    margin: 0;
    font-family: 'Helvetica Neue', Arial, sans-serif;
    background: linear-gradient(135deg, #134E5E, #71B280);
    height: 100vh;
    width: 100vw;
    display: flex;
    justify-content: center;
    align-items: center;
    color: #fff;
    overflow: hidden;
  }

  /* === ãƒ¡ã‚¤ãƒ³ã®ã‚³ãƒ³ãƒ†ãƒŠãƒœãƒƒã‚¯ã‚¹ === */
  .box {
    background: rgba(255, 255, 255, 0.95);
    color: #333;
    padding: 15px;
    border-radius: 15px;
    box-shadow: 0 20px 50px rgba(0,0,0,0.5);
    display: flex;
    gap: 20px;
    max-width: 950px;
    width: 95%;
    max-height: 98vh;
    position: relative;
    box-sizing: border-box;
  }

  /* === ç›¤é¢ã‚¨ãƒªã‚¢ === */
  .board-section {
    flex: 2;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
  }
  .board-wrap {
    border: 5px solid #2E7D32;
    border-radius: 4px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.4);
    width: 100%;
    max-width: 60vh;
    aspect-ratio: 1 / 1;
    position: relative;
    transition: box-shadow 0.3s, border-color 0.3s;
    touch-action: none; 
  }
     
  #board {
    width: 100%;
    height: 100%;
    touch-action: none; 
  }
      
  .in-check-danger {
    border-color: #c0392b !important; 
    box-shadow: 0 0 25px rgba(192, 57, 43, 0.8) !important;
  }

  /* === æƒ…å ±ã‚¨ãƒªã‚¢ï¼ˆå³å´ï¼‰ === */
  .info-section {
    flex: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 10px;
    overflow-y: auto;
  }

  /* === ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã‚¢ã‚¤ã‚³ãƒ³ === */
  .mascot {
    font-size: 50px;
    background: #fff;
    width: 80px;
    height: 80px;
    border-radius: 50%;
    display: flex;
    justify-content: center;
    align-items: center;
    border: 4px solid #ccc;
    margin-bottom: 5px;
    flex-shrink: 0; 
    box-shadow: 0 4px 10px rgba(0,0,0,0.1);
    transition: 0.3s;
  }
     
  .active-turn {
    border-color: #2ecc71 !important;
    box-shadow: 0 0 25px rgba(46, 204, 113, 1.0) !important;
    transform: scale(1.05);
  }

  /* === å½¢å‹¢åˆ¤æ–­ã‚²ãƒ¼ã‚¸ === */
  .eval-gauge-container {
    width: 100%;
    height: 8px;
    background: #555;
    margin-bottom: 10px;
    border-radius: 4px;
    overflow: hidden;
    display: flex;
    flex-shrink: 0;
  }
  .eval-bar-white { height: 100%; background: #2ecc71; width: 50%; transition: width 0.5s ease-out; }

  /* === å¹ãå‡ºã— & ãƒ«ãƒ¼ãƒ« === */
  .bubble {
    position: relative;
    background: #ecf0f1;
    color: #2c3e50;
    border-radius: 12px;
    padding: 10px;
    width: 100%;
    margin-bottom: 10px;
    min-height: 60px; 
    font-size: 13px;
    box-sizing: border-box;
    border: 2px solid #bdc3c7;
    display: flex;
    align-items: center;
    justify-content: center;
    text-align: center;
    font-weight: bold;
    flex-shrink: 0;
  }
  .bubble::after {
    content: '';
    position: absolute;
    top: -12px;
    left: 50%;
    transform: translateX(-50%);
    border: 12px solid transparent;
    border-bottom-color: #bdc3c7;
  }
      
  /* ãƒ«ãƒ¼ãƒ«èª¬æ˜ã‚¨ãƒªã‚¢ */
  .sidebar-rules {
    width: 100%;
    background: #f1f8e9;
    border: 1px solid #c5e1a5;
    border-radius: 8px;
    padding: 8px;
    margin-bottom: 5px;
    font-size: 0.75em;
    color: #33691e;
    box-sizing: border-box;
    text-align: left;
    overflow-y: auto;
    flex-grow: 1;
    min-height: 0;
  }
  .sidebar-rules h4 { margin: 0 0 3px 0; border-bottom: 1px solid #aed581; padding-bottom: 2px; }
  .sidebar-rules ul { margin: 0; padding-left: 15px; }
  .sidebar-rules li { margin-bottom: 2px; }

  /* === ãƒœã‚¿ãƒ³é¡ === */
  .btn-group { 
    width: 100%; 
    display: flex; flex-direction: column; 
    gap: 5px; 
    margin-top: auto; 
    flex-shrink: 0;
  }
  .btn {
    border: none; 
    padding: 10px; 
    border-radius: 6px; 
    font-weight: bold; 
    cursor: pointer; 
    width: 100%; 
    color: white; 
    transition: 0.2s; 
    font-size: 13px;
  }
  .btn-hint { background: #e67e22; } .btn-hint:hover { background: #d35400; }
  .btn-undo { background: #9b59b6; } .btn-undo:hover { background: #8e44ad; } 
  .btn-auto { background: #2ecc71; } .btn-auto:hover { background: #27ae60; }
  .btn-auto-active { background: #e74c3c !important; }
  .btn-retry { background: #3498db; } .btn-retry:hover { background: #2980b9; }
  .btn-reset { background: #95a5a6; } .btn-reset:hover { background: #7f8c8d; }
  .btn-disabled { background: #bdc3c7 !important; cursor: not-allowed; opacity: 0.6; }
  .hidden { display: none !important; }

  /* === ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ï¼ˆãƒ¡ãƒ‹ãƒ¥ãƒ¼ç”»é¢ï¼‰ === */
  .overlay {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(20, 50, 30, 0.98); 
    z-index: 100; 
    display: flex; 
    flex-direction: column; justify-content: center; align-items: center; 
    color: #fff; 
    border-radius: 15px; 
    padding: 20px; 
    box-sizing: border-box;
  }
  .menu-btn {
    background: #2ecc71; color: #fff; font-weight: bold; cursor: pointer; margin-top: 30px;
    padding: 15px 30px; font-size: 18px; border:none; border-radius: 5px; width: 100%;
  }

  /* === ç›¤é¢ã®ãƒã‚¤ãƒ©ã‚¤ãƒˆæ¼”å‡º === */
  .highlight-move { background: radial-gradient(circle, rgba(46, 204, 113, 0.7) 20%, transparent 20%); }
  .highlight-capture { background-color: rgba(231, 76, 60, 0.5) !important; box-shadow: inset 0 0 0 4px rgba(192, 57, 43, 0.9) !important; }
  .highlight-danger-source { 
    background-color: rgba(255, 120, 0, 0.85) !important; 
    box-shadow: inset 0 0 15px rgba(255, 50, 0, 0.8) !important; 
    animation: flash-orange 1.2s infinite alternate;
    z-index: 10; 
  }
  @keyframes flash-orange { from { opacity: 0.8; } to { opacity: 1.0; } }
  .highlight-hint { 
    background: rgba(255, 235, 59, 0.7); 
    box-shadow: inset 0 0 10px rgba(255, 215, 0, 1.0); 
    animation: flash-yellow 0.8s infinite alternate; 
  }
  @keyframes flash-yellow { from { opacity: 0.6; } to { opacity: 1.0; } }

  /* === ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–å¯¾å¿œï¼ˆã‚¹ãƒãƒ›å‘ã‘ï¼‰ === */
  @media(max-width:768px){
    body { 
        padding: 0; 
        align-items: flex-start; /* ä¸Šè©°ã‚ */
    }
    .box { 
        flex-direction: column; 
        height: 100vh; /* ç”»é¢ã„ã£ã±ã„ */
        max-height: 100vh;
        width: 100%; 
        border-radius: 0; 
        padding: 5px; /* ä½™ç™½å‰Šæ¸› */
        margin: 0; 
        gap: 5px;
    }
     
    /* æƒ…å ±ã‚¨ãƒªã‚¢ã‚’ä¸Šã«é…ç½® */
    .info-section { 
        order: -1; 
        width:100%; 
        padding: 2px;
        flex-direction: row; /* æ¨ªä¸¦ã³ã«ã—ã¦çœã‚¹ãƒšãƒ¼ã‚¹åŒ– */
        flex-wrap: wrap;
        justify-content: center;
        gap: 10px;
        flex: 0 0 auto; /* é«˜ã•ã‚’å›ºå®š */
    } 
     
    .mascot { width: 50px; height: 50px; font-size: 30px; margin: 0; }
    .status-wrap { display: flex; flex-direction: column; justify-content: center; flex: 1; }
    .eval-gauge-container { margin-bottom: 5px; height: 6px; }
    #status { font-size: 1em; margin-bottom: 0; text-align: center; }

    /* å¹ãå‡ºã—ã‚’å°ã•ã */
    .bubble { 
        width: 100%; 
        margin: 5px 0; 
        min-height: 40px; 
        padding: 5px; 
        font-size: 12px;
        order: 3; /* ä¸€ç•ªä¸‹ã¸ */
    }
    .bubble::after { display: none; } /* ã—ã£ã½å‰Šé™¤ */

    /* ç›¤é¢ã‚¨ãƒªã‚¢ */
    .board-section { 
        flex: 1; /* æ®‹ã‚Šã®ã‚¹ãƒšãƒ¼ã‚¹ã‚’ä½¿ã† */
        padding: 0;
        justify-content: flex-start;
    }
    /* ç›¤é¢ã‚µã‚¤ã‚ºèª¿æ•´ï¼šç”»é¢å¹…ã«åˆã‚ã›ã¦æ­£æ–¹å½¢ã‚’ç¶­æŒ */
    .board-wrap { 
        width: 100%; 
        max-width: 95vw; /* ç”»é¢å¹…ã®95% */
        height: auto; 
        aspect-ratio: 1/1; 
    }
     
    /* ã‚¹ãƒãƒ›ã§ã¯ãƒ«ãƒ¼ãƒ«èª¬æ˜ã‚’å®Œå…¨ã«éš ã™ï¼ˆã‚¹ãƒšãƒ¼ã‚¹ç¢ºä¿ï¼‰ */
    .sidebar-rules { display: none; }
     
    /* ãƒœã‚¿ãƒ³ã‚¨ãƒªã‚¢ */
    .btn-group {
        flex-direction: row; /* æ¨ªä¸¦ã³ */
        flex-wrap: wrap;
    }
    .btn { width: 48%; font-size: 11px; padding: 8px; flex: 1; }
  }
</style>
</head>
<body>

<div class="box">
  <div id="menu" class="overlay">
    <div style="width:100%; max-width:400px; text-align:center;">
      <h1 style="font-size:2.5em; margin:0 0 20px 0;">â™š AI Chess</h1>
      <a href="a10.html">Ver.0.1.0ã¸</a><a href="a115.html">Ver.1.1.5ã¸</a>
      <div style="display:flex; gap:20px; width:100%;">
        <div style="flex:1;">
          <p style="font-weight:bold;">è‰²</p>
          <select id="color-select" style="width:100%; padding:8px;">
              <option value="w">â™” å…ˆæ‰‹ (ç™½)</option>
              <option value="b">â™š å¾Œæ‰‹ (é»’)</option>
          </select>
        </div>
        <div style="flex:1;">
          <p style="font-weight:bold;">ãƒ¬ãƒ™ãƒ«</p>
          <select id="level" style="width:100%; padding:8px;">
            <option value="1">ğŸŒ± å…¥é–€ (é›‘é­š)</option>
            <option value="2">ğŸŒ² ä¸­ç´š (æ™®é€š)</option>
            <option value="3" selected>ğŸ‰ è¶…ç´š (æœ€å¼·)</option>
          </select>
        </div>
      </div>
      <button class="menu-btn" onclick="startGame()">ğŸ® ã‚²ãƒ¼ãƒ ã‚¹ã‚¿ãƒ¼ãƒˆï¼</button>
    </div>
  </div>

  <div class="board-section">
    <div class="board-wrap">
        <div id="board"></div>
    </div>
  </div>

  <div class="info-section">
    <div class="mascot" id="face">ğŸ˜</div>
     
    <div class="status-wrap" style="width: 100%; max-width: 300px;">
        <div class="eval-gauge-container">
            <div id="eval-bar-white" class="eval-bar-white"></div>
        </div>
        <div id="status" style="font-weight:bold; font-size: 1.2em;">æº–å‚™ä¸­...</div>
    </div>

    <div class="bubble" id="msg">è¨­å®šã‚’é¸ã‚“ã§ã‚¹ã‚¿ãƒ¼ãƒˆã—ã¦ã­ï¼</div>
     
    <div class="sidebar-rules">
        <h4>ğŸ“œ ã–ã“ã–ã“ãƒ«ãƒ¼ãƒ«</h4>
        <ul>
            <li>ç‹æ§˜(ã‚­ãƒ³ã‚°)ã‚’è©°ã¾ã›ã°å‹ã¡â™¥</li>
            <li>é§’ã¯ãƒ‰ãƒ©ãƒƒã‚°ã§å‹•ã‹ã—ã¦ã­ã€‚</li>
        </ul>
        <div style="font-size:0.9em; margin-top:5px; line-height:1.4;">
            <b>â™™ãƒãƒ¼ãƒ³</b>: å‰1æ­©ã€‚æ•µã¯æ–œã‚ã€‚<br>
            <b>â™˜ãƒŠã‚¤ãƒˆ</b>: Lå­—ã‚¸ãƒ£ãƒ³ãƒ—ã€‚<br>
            <b>â™—ãƒ“ã‚·ãƒ§ãƒƒãƒ—</b>: æ–œã‚ã€‚<br>
            <b>â™–ãƒ«ãƒ¼ã‚¯</b>: ç¸¦æ¨ªã€‚<br>
            <b>â™•ã‚¯ã‚¤ãƒ¼ãƒ³</b>: ç¸¦æ¨ªæ–œã‚ã€‚<br>
            <b>â™”ã‚­ãƒ³ã‚°</b>: å‘¨å›²1æ­©ã€‚
        </div>
    </div>

    <div class="btn-group">
      <button class="btn btn-hint" id="btn-hint" onclick="showHint()">ğŸ’¡ ãƒ’ãƒ³ãƒˆ</button>
      <button class="btn btn-undo" id="btn-undo" onclick="undoMove()">â†©ï¸ å¾…ã£ãŸ</button>
      <button class="btn btn-auto" id="btn-auto" onclick="toggleAutoPlay()">ğŸ¤– ã‚ªãƒ¼ãƒˆ</button>
      <button class="btn btn-retry hidden" id="btn-retry" onclick="startGame()">ğŸ”„ å†æˆ¦</button>
      <button class="btn btn-reset" onclick="location.reload()">ğŸ  æˆ»ã‚‹</button>
    </div>
  </div>
</div>

<script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
<script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>

<script>
// === ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°å®šç¾© ===
const game = new Chess();
let board = null;
let aiLevel = 3; 
let isAuto = false;
let autoTimer = null;
let playerColor = 'w';
let audioCtx = null;
let currentDragHover = null; 
let dragSimGame = null;

// === çµµæ–‡å­—å®šç¾©ï¼ˆè¡¨æƒ…ã®ã¿ï¼‰ ===
const EMOJI_SELF = "ğŸ§™â€â™‚ï¸"; 
const EMOJI_ROBOT = "ğŸ¤–"; 
const EMOJI_SCARED = "ğŸ˜±"; // ç‹æ‰‹ã•ã‚ŒãŸæ™‚

// AIã®é¡”ãƒãƒªã‚¨ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆçŠ¶æ…‹åˆ¥ï¼‰
// ä½™è£•ï¼ˆç”Ÿæ„æ°—ï¼‰
const EMOJI_WINNING = ["ğŸ˜", "ğŸ˜—", "ğŸ¤­", "ğŸ˜", "ğŸ˜ˆ"]; 
// æ™®é€šï¼ˆæ€è€ƒä¸­ãƒ»é€€å±ˆï¼‰
const EMOJI_NORMAL = ["ğŸ¤”", "ğŸ¤¨", "ğŸ¥±", "ğŸ˜"]; 
// åŠ£å‹¢ï¼ˆç„¦ã‚Šãƒ»ã‚ã‹ã‚‰ã›ï¼‰
const EMOJI_LOSING = ["ğŸ˜–", "ğŸ¥º", "ğŸ˜­", "ğŸ˜µâ€ğŸ’«", "ğŸ§Š"]; 

const ui = { 
  face: $('#face'), msg: $('#msg'), status: $('#status'), 
  btnAuto: $('#btn-auto'), btnHint: $('#btn-hint'), btnUndo: $('#btn-undo'), btnRetry: $('#btn-retry'), 
  evalWhite: $('#eval-bar-white'), boardWrap: $('.board-wrap') 
};

// === ã‚»ãƒªãƒ•è¾æ›¸ï¼ˆå½¢å‹¢å„ªå…ˆå‹ãƒ»ã‚ã‹ã‚‰ã›ä»•æ§˜ï¼‰ ===
// æ§‹é€ : [Action]_[Situation]
// Situation: Winning (AIå„ªå‹¢), Even (äº’è§’), Losing (AIåŠ£å‹¢/ã‚ã‹ã‚‰ã›)

const msgDict = {
  start: ["ãµã€œã‚“ã€ç§ã«å‹ã¦ã‚‹ã¨æ€ã£ã¦ã‚‹ã‚“ã ï¼Ÿ", "ã–ã“ã–ã“ã•ã‚“ã€ã„ã‚‰ã£ã—ã‚ƒã€œã„", "ãƒœã‚³ãƒœã‚³ã«ã—ã¦ã‚ã’ã‚‹ã‹ã‚‰è¦šæ‚Ÿã—ãªã‚ˆï¼Ÿ"],
  
  // --- AIã®æ‰‹ç•ª (AIãŒæŒ‡ã—ãŸç›´å¾Œ) ---
  
  // AIãŒç‹æ‰‹ã—ãŸ
  ai_check_Winning: ["ã»ã‚‰ã»ã‚‰ã€ç‹æ‰‹ã ã‚ˆã€œâ™¡", "é€ƒã’ãªã„ã¨çµ‚ã‚ã£ã¡ã‚ƒã†ã‚ˆï¼Ÿ", "è¨ˆç®—é€šã‚Šã™ãã¦ã‚‚ã†ç¬‘ã£ã¡ã‚ƒã†"],
  ai_check_Even:    ["ç‹æ‰‹ï¼ ã¡ã‚‡ã£ã¨ã¯ç„¦ã£ã¦ãã‚ŒãŸï¼Ÿ", "æ¬¡ã§è©°ã‚“ã˜ã‚ƒã†ã‹ã‚‚ã­ã€œ", "ã“ã“ã€ç‹™ã„ç›®ã ã£ãŸã§ã—ã‚‡ï¼Ÿ"],
  ai_check_Losing:  ["ã“ã€ã“ã‚Œãªã‚‰ã©ã†ã â€¦ï¼", "ã¾ã â€¦ã¾ã çµ‚ã‚ã£ã¦ãªã„ã‚‚ã‚“ï¼", "ã†ã‚‹ã•ã„ï¼ ã“ã‚Œã§åæ’ƒé–‹å§‹ãªã‚“ã ã‹ã‚‰ï¼"], // è‹¦ã—ç´›ã‚Œ
  
  // AIãŒé§’ã‚’å–ã£ãŸ
  ai_capture_Winning: ["ã„ãŸã ãã¾ã€œã™â™¡", "éš™ã ã‚‰ã‘ã§ã‚¦ã‚±ã‚‹ï½—", "å¤§äº‹ãªé§’ã€æ¸›ã£ã¡ã‚ƒã£ãŸã­ã€œï¼Ÿ"],
  ai_capture_Even:    ["ã”ã¡ãã†ã•ã¾ï¼", "æ²¹æ–­ã—ãŸã­ï¼Ÿ", "ä¸€ã¤ã‚²ãƒƒãƒˆï¼"],
  ai_capture_Losing:  ["ã¨ã€ã¨ã‚Šã‚ãˆãšä¸€ã¤è¿”ã—ãŸã—â€¦ï¼", "èª¿å­ã«ä¹—ã‚‹ãªâ€¦èª¿å­ã«ä¹—ã‚‹ãªâ€¦ï¼", "ãã£â€¦ã“ã‚Œãã‚‰ã„ã§å‹ã£ãŸæ°—ã«ãªã‚‹ãªã‚ˆï¼"], // å¿…æ­»
  
  // AIã®é€šå¸¸ç§»å‹•
  ai_move_Winning: ["ç„¡é§„ãªæŠµæŠ—ãŠã¤ã‹ã‚Œã•ã¾ã€œ", "ã‚‚ã†è«¦ã‚ãŸã‚‰ï¼Ÿ æ¥½ã«ãªã‚‹ã‚ˆï¼Ÿ", "ã‚ã¯ã¯ï¼ å¿…æ­»ã ã­ã‡ã€æ»‘ç¨½ã ã‚ˆ"],
  ai_move_Even:    ["ãµãƒ¼ã‚“ã€ãã†æ¥ã‚‹ã‚“ã ", "ã¾ã€æ‚ªããªã„ã‚“ã˜ã‚ƒãªã„ï¼Ÿ", "è¨ˆç®—é€šã‚Šã ã—ã€å•é¡Œãªã„ã­"],
  ai_move_Losing:  ["ãã¬ã¬â€¦ãªã‚“ã§ã“ã‚“ãªæ‰‹ãŒâ€¦", "ã†ã€å˜˜ã§ã—ã‚‡â€¦ï¼Ÿ ç§ãŒè² ã‘ã‚‹â€¦ï¼Ÿ", "æ‰‹ãŒéœ‡ãˆã¦â€¦ã„ã‚„ã€ãªã‚“ã§ã‚‚ãªã„ã—ï¼"], // ç„¦ã‚Š

  // --- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æ‰‹ç•ª (ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒæŒ‡ã—ãŸç›´å¾Œ) ---

  // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«ç‹æ‰‹ã•ã‚ŒãŸ
  player_check_Winning: ["ã¯ã„ã¯ã„ã€ç‹æ‰‹ã­ã€‚è¦‹ãˆã¦ã‚‹ã£ã¦", "ãã‚“ãªè„…ã—ã€åŠ¹ã‹ãªã„ã‚ˆã€œã ", "å¿…æ­»ã ã­ã‡ï½— ã§ã‚‚å±Šã‹ãªã„ã‚ˆï¼Ÿ"],
  player_check_Even:    ["ã£ï¼ï¼Ÿ ç‹æ‰‹â€¦ã‚„ã‚‹ã˜ã‚ƒã‚“", "ã‚€â€¦ã¡ã‚‡ã£ã¨æ²¹æ–­ã—ãŸã‹ãª", "ç”Ÿæ„æ°—ãªâ€¦ï¼"],
  player_check_Losing:  ["ã²ã£â€¦ï¼ ã”ã‚ã‚“ãªã•ã„ï¼", "ã†ã…â€¦ã„ã˜ã‚ãªã„ã§ã‚ˆã‰â€¦", "è² ã‘ãŸããªã„â€¦è² ã‘ãŸããªã„ã‚ˆã‰â€¦ï¼"], // å®Œå…¨ã‚ã‹ã‚‰ã›
  
  // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«é§’ã‚’å–ã‚‰ã‚ŒãŸ
  player_capture_Winning: ["ã‚ãƒ¼ã‚ã€ãã‚Œæ¬²ã—ã‹ã£ãŸã®ï¼Ÿ ä¸Šã’ã‚‹ã‚ˆï½—", "æ¨ã¦é§’ã«å¿…æ­»ã«ãªã£ã¡ã‚ƒã£ã¦ï½—", "èª¤å·®ã ã‚ˆã€èª¤å·®ï½—"],
  player_capture_Even:    ["ã‚€ã£ã€ã‚„ã‚‹ã­â€¦", "ãã‚Œå–ã‚‰ã‚Œã‚‹ã®ã¯è¨ˆç®—å¤–â€¦", "ãƒãƒƒã€å°ç™ªãªçœŸä¼¼ã‚’â€¦"],
  player_capture_Losing:  ["ã‚„ã‚ã¦ï¼ ç§ã®é§’ãŒããï¼", "ã†ãâ€¦ãªã‚“ã§ãã‚“ãªé…·ã„ã“ã¨ã™ã‚‹ã®â€¦", "ã‚‚ã†ã‚„ã‚ã¦â€¦è¨±ã—ã¦ã‚ˆã‰â€¦"], // æ³£ã

  // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®é€šå¸¸ç§»å‹•
  player_move_Winning: ["ãµãã€œã‚ã€é€€å±ˆãªæ‰‹ã ã­ã‡", "ãã‚“ãªæ‰‹ã§é€†è»¢ã§ãã‚‹ã¨ã§ã‚‚ï¼Ÿ", "å‹ã¡ãŒè¦‹ãˆã¡ã‚ƒã£ã¦ã¤ã¾ã‚“ãªã„ãªã€œ"],
  player_move_Even:    ["ã¸ã‡ã€ãã†å‹•ãã‚“ã ", "ãªã‚‹ã»ã©ã­â€¦ã§ã‚‚æ¬¡ã¯ã©ã†ã™ã‚‹ï¼Ÿ", "ã¾ã å‹è² ã¯ã“ã‚Œã‹ã‚‰ã ã‚ˆ"],
  player_move_Losing:  ["ãªã‚“ã§â€¦ãªã‚“ã§ãã‚“ãªã«å¼·ã„ã®â€¦ï¼Ÿ", "ã†ã…â€¦é ­ãŒçœŸã£ç™½ã ã‚ˆã‰â€¦", "ã“ã®ç§ãŒâ€¦è¿½ã„è©°ã‚ã‚‰ã‚Œã¦ã‚‹â€¦ï¼Ÿ"], // çµ¶æœ›

  // --- å‹æ•— ---
  win: ["ã¯ã„ç§ã®å‹ã¡ã€œï¼ ã‚ˆã‚ã‚ˆã‚ã™ãã€œï½—", "ã–ã€œã“â™¡ ã–ã€œã“â™¡ å‡ºç›´ã—ã¦ããªï¼", "å£ã»ã©ã«ã‚‚ãªã„ã­ã‡ã€ã·ã·ã£"],
  lose: ["ã†ãâ€¦è² ã‘ãŸâ€¦ï¼Ÿ ãã™ã£â€¦", "ã†ã‚ã‚ã‚ã‚ã‚“ï¼ è¦šãˆã¦ãªã•ã„ã‚ˆã‰ï¼", "æ‚”ã—ã„â€¦æ‚”ã—ã„ã‚ˆã‰â€¦", "ä»Šå›ã ã‘ã¯â€¦èªã‚ã¦ã‚ã’ã‚‹â€¦"],
  draw: ["ã¡ã£ã€å¼•ãåˆ†ã‘ã‹ãâ€¦", "é€ƒã’åˆ‡ã£ã¦æº€è¶³ï¼Ÿ ã¤ã¾ã‚“ãªã„ã®ã€‚", "ã¾ã€è² ã‘ãªã‹ã£ãŸã—ï¼"],
  
  // --- ãã®ä»– ---
  invalidMove: ["ãˆï¼Ÿ ãƒ«ãƒ¼ãƒ«ã‚‚çŸ¥ã‚‰ãªã„ã®ï¼Ÿ", "ãã“ã«ã¯å‹•ã‘ãªã„ã‚ˆï¼Ÿ ã·ã·ã£", "ã‚‚ã—ã‹ã—ã¦ã€ã‚ã–ã¨é–“é•ãˆã¦ã‚‹ï¼Ÿ"],
  ignoreCheck: ["ã­ãˆã€ç‹æ§˜æ­»ã‚“ã˜ã‚ƒã†ã‚ˆï¼Ÿï½—", "ãƒã€œã‚«ï¼ ç‹æ‰‹è¦‹ãˆã¦ãªã„ã®ï¼Ÿ", "ã‚ã¯ã¯ï¼ è² ã‘ãŸã„ã‚“ã ã€œ"],
  autoOn: ["ãˆã‡ã€œï¼Ÿ æ©Ÿæ¢°ã«é ¼ã£ã¡ã‚ƒã†ã‚“ã ï¼Ÿ", "è‡ªåˆ†ã§å‹ã¦ãªã„ã‹ã‚‰ã£ã¦ãƒ€ãƒƒã‚µã€œï½—", "ãƒ—ãƒ©ã‚¤ãƒ‰ãªã„ã®ã€œï¼Ÿ"],
  hint: ["ã—ã‚‡ã†ãŒãªã„ãªãâ€¦ã“ã“å‹•ã‹ã›ã°ï¼Ÿ", "ã»ã‚‰ã€ç‰¹åˆ¥ã«æ•™ãˆã¦ã‚ã’ã‚‹", "ã“ã‚“ãªæ‰‹ã‚‚è¦‹ãˆãªã„ã®ï¼Ÿ"],
  undo: ["å¾…ã£ãŸï¼Ÿ å¾€ç”Ÿéš›ãŒæ‚ªã„ãªãâ€¦", "ãˆãƒ¼ã€ãšã‚‹ããªã„ï¼Ÿ ã¾ã€ã„ã„ã‘ã©", "ã¯ã„ã¯ã„ã€è¦‹ãªã‹ã£ãŸã“ã¨ã«ã—ã¦ã‚ã’ã‚‹"]
};

function getRandom(arr) { return arr[Math.floor(Math.random() * arr.length)]; }
function getRandomMsg(key) { 
    return getRandom(msgDict[key] || ["..."]); 
}

function initAudio() { if(!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)(); if(audioCtx.state==='suspended') audioCtx.resume(); }
function playSound(type) {
  if(!audioCtx) return;
  const t = audioCtx.currentTime;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  
  if (type === 'move') {
    osc.frequency.setValueAtTime(180, t); osc.frequency.exponentialRampToValueAtTime(40, t+0.12);
    gain.gain.setValueAtTime(0.4, t); gain.gain.exponentialRampToValueAtTime(0.01, t+0.12);
    osc.start(t); osc.stop(t+0.12);
  } else if (type === 'capture') {
    osc.type = 'triangle'; osc.frequency.setValueAtTime(350, t); osc.frequency.exponentialRampToValueAtTime(60, t+0.15);
    gain.gain.setValueAtTime(0.4, t); gain.gain.exponentialRampToValueAtTime(0.01, t+0.15);
    osc.start(t); osc.stop(t+0.15);
  } else if (type === 'start') {
    osc.frequency.setValueAtTime(440, t); osc.frequency.linearRampToValueAtTime(880, t+0.3);
    gain.gain.setValueAtTime(0.1, t); gain.gain.linearRampToValueAtTime(0, t+0.5);
    osc.start(t); osc.stop(t+0.5);
  }
}

// === AIé–¢é€£ ===
const PST={
    p:[0,0,0,0,0,0,0,0,50,50,50,50,50,50,50,50,10,10,20,30,30,20,10,10,5,5,10,25,25,10,5,5,0,0,0,20,20,0,0,0,5,-5,-10,0,0,-10,-5,5,5,10,10,-20,-20,10,10,5,0,0,0,0,0,0,0,0],
    n:[-50,-40,-30,-30,-30,-30,-40,-50,-40,-20,0,0,0,0,-20,-40,-30,0,10,15,15,10,0,-30,-30,5,15,20,20,15,5,-30,-30,0,15,20,20,15,0,-30,-30,5,10,15,15,10,5,-30,-40,-20,0,5,5,0,-20,-40,-50,-40,-30,-30,-30,-30,-40,-50],
    b:[-20,-10,-10,-10,-10,-10,-10,-20,-10,0,0,0,0,0,0,-10,-10,0,5,10,10,5,0,-10,-10,5,5,10,10,5,5,-10,-10,0,10,10,10,10,0,-10,-10,10,10,10,10,10,10,-10,-10,5,0,0,0,0,5,-10,-20,-10,-10,-10,-10,-10,-10,-20],
    r:[0,0,0,0,0,0,0,0,5,10,10,10,10,10,10,5,-5,0,0,0,0,0,0,-5,-5,0,0,0,0,0,0,-5,-5,0,0,0,0,0,0,-5,-5,0,0,0,0,0,0,-5,-5,0,0,0,0,0,0,-5,0,0,0,5,5,0,0,0],
    q:[-20,-10,-10,-5,-5,-10,-10,-20,-10,0,0,0,0,0,0,-10,-10,0,5,5,5,5,0,-10,-5,0,5,5,5,5,0,-5,0,0,5,5,5,5,0,-5,-10,5,5,5,5,5,0,-10,-10,0,5,0,0,0,0,-10,-20,-10,-10,-5,-5,-10,-10,-20],
    k:[-30,-40,-40,-50,-50,-40,-40,-30,-30,-40,-40,-50,-50,-40,-40,-30,-30,-40,-40,-50,-50,-40,-40,-30,-30,-40,-40,-50,-50,-40,-40,-30,-20,-30,-30,-40,-40,-30,-30,-20,-10,-20,-20,-20,-20,-20,-20,-10,20,20,0,0,0,0,20,20,20,30,10,0,0,10,30,20]
};
const VAL={p:100,n:320,b:330,r:500,q:900,k:20000};

function getBoardValue(g) {
  let v = 0; const b = g.board();
  for(let r=0; r<8; r++) for(let c=0; c<8; c++) {
    const p = b[r][c];
    if(p) {
      let score = VAL[p.type] + (PST[p.type][p.color==='w'?(r*8+c):((7-r)*8+c)]||0);
      v += (p.color==='w' ? score : -score);
    }
  }
  return v;
}

function orderMoves(moves) {
  return moves.sort((a,b)=>{
    let sA=0,sB=0;
    if(a.flags.includes('c')) sA+=10+(VAL[a.captured]||0)-(VAL[a.piece]||0)/10;
    if(a.flags.includes('p')) sA+=100;
    if(b.flags.includes('c')) sB+=10+(VAL[b.captured]||0)-(VAL[b.piece]||0)/10;
    if(b.flags.includes('p')) sB+=100;
    return sB-sA;
  });
}

function minimax(g, depth, alpha, beta, isMax) {
  if (depth===0 || g.game_over()) return getBoardValue(g);
  let moves = orderMoves(g.moves({ verbose: true }));
  if(moves.length === 0) return getBoardValue(g);
  
  if (isMax) {
    let maxEval = -Infinity;
    for (let m of moves) {
      g.move(m); 
      let eval = minimax(g, depth-1, alpha, beta, false); 
      g.undo();
      maxEval = Math.max(maxEval, eval); 
      alpha = Math.max(alpha, eval);
      if (beta <= alpha) break;
    }
    return maxEval;
  } else {
    let minEval = Infinity;
    for (let m of moves) {
      g.move(m); 
      let eval = minimax(g, depth-1, alpha, beta, true); 
      g.undo();
      minEval = Math.min(minEval, eval); 
      beta = Math.min(beta, eval);
      if (beta <= alpha) break;
    }
    return minEval;
  }
}

function getBestMove(levelOverride) {
  const currentLevel = levelOverride || aiLevel;
  const moves = game.moves({ verbose: true });
  if (!moves.length) return null;
  
  if (currentLevel === 1) {
    if(Math.random()<0.5) return getRandom(moves);
    const captures = moves.filter(m => m.flags.includes('c'));
    return captures.length ? getRandom(captures) : getRandom(moves);
  }
  
  const depth = (currentLevel === 2) ? 2 : 3;
  const isWhite = (game.turn() === 'w');
  let bestMove = null; 
  let bestVal = isWhite ? -Infinity : Infinity;
  const orderedMoves = orderMoves(moves);
  
  for(let m of orderedMoves) {
    game.move(m);
    let val = minimax(game, depth - 1, -Infinity, Infinity, !isWhite);
    game.undo();
    if(isWhite) { if(val > bestVal) { bestVal = val; bestMove = m; } }
    else { if(val < bestVal) { bestVal = val; bestMove = m; } }
  }
  return bestMove || getRandom(moves);
}

// === ã‚²ãƒ¼ãƒ é€²è¡Œãƒ­ã‚¸ãƒƒã‚¯ ===
function startGame() {
  initAudio(); playSound('start');
  playerColor = $('#color-select').val();
  aiLevel = parseInt($('#level').val());
  $('#menu').addClass('hidden');
  game.reset(); 
  isAuto = false; 
  clearTimeout(autoTimer);
  $('#board').empty();
  
  ui.btnRetry.addClass('hidden');
  ui.btnAuto.show().removeClass('hidden');
  ui.btnHint.show().removeClass('hidden').prop('disabled', false).removeClass('btn-disabled');
  ui.btnUndo.show().removeClass('hidden').prop('disabled', false).removeClass('btn-disabled');
  
  const orient = playerColor==='w'?'white':'black';
  const pieceTheme = p => {
    const c = p[0]==='w'?'#fff':'#000', s = p[0]==='w'?'#000':'#fff';
    const sym = {'P':'â™™','N':'â™˜','B':'â™—','R':'â™–','Q':'â™•','K':'â™”','p':'â™Ÿ','n':'â™','b':'â™','r':'â™œ','q':'â™›','k':'â™š'};
    return 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 60 60"><text x="50%" y="58%" text-anchor="middle" dominant-baseline="middle" font-family="sans-serif" font-size="50" fill="${c}" stroke="${s}" stroke-width="1.5">${sym[p[1]]||'?'}</text></svg>`);
  };

  board = Chessboard('board', {
    draggable: true, 
    position: 'start', 
    orientation: orient, 
    pieceTheme: pieceTheme,
    onDragStart: onDragStart, 
    onDragMove: onDragMove, 
    onDrop: onDrop, 
    onSnapEnd: onSnapEnd
  });
  
  $(window).resize(board.resize);
  ui.msg.text(getRandomMsg('start'));
  ui.btnAuto.removeClass('btn-auto-active').text("ğŸ¤– ã‚ªãƒ¼ãƒˆ: OFF");
  updateStatus(null);
  
  // AIãŒå…ˆæ‰‹(ç™½)ã®å ´åˆã€åˆæ‰‹ã‚’æ‰“ã¤
  if (playerColor === 'b') {
      gameLoop();
  }
}

function gameLoop() {
  clearTimeout(autoTimer);
  if(game.game_over()) return;

  const myTurn = (game.turn() === playerColor);
  if (myTurn && !isAuto) return;
  
  autoTimer = setTimeout(() => {
    makeAiMove();
  }, 600);
}

function makeAiMove() {
  if (game.game_over()) return;

  const turnColor = game.turn();
  const isEnemy = (turnColor !== playerColor);
  const useLevel = isEnemy ? aiLevel : 3;
  
  const m = getBestMove(useLevel);
  if (m) {
    const moveResult = game.move(m);
    board.position(game.fen());
    playSound(moveResult.flags.includes('c') ? 'capture' : 'move');
    
    // AIã®æ‰‹ç•ªãŒçµ‚ã‚ã£ãŸã®ã§ã€çŠ¶æ…‹æ›´æ–°
    updateTurnMessage(moveResult, false); // isPlayerMove = false (AIãŒå‹•ã‹ã—ãŸ)
    updateStatus(moveResult); 
    
    gameLoop(); 
  }
}

// === ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ“ä½œã‚¤ãƒ™ãƒ³ãƒˆ ===
function onDragStart(source, piece) {
  if (game.game_over() || isAuto) return false;
  if (game.turn() !== playerColor) return false;
  if ((playerColor === 'w' && piece.search(/^b/) !== -1) || (playerColor === 'b' && piece.search(/^w/) !== -1)) return false;
  
  const moves = game.moves({ square: source, verbose: true });
  if (moves.length === 0) return false;

  dragSimGame = new Chess(game.fen());

  removeHighlights();
  moves.forEach(m => {
    $('#board .square-' + m.to).addClass(m.flags.includes('c') ? 'highlight-capture' : 'highlight-move');
  });
}

function onDragMove(newLocation, oldLocation, source, piece) {
  if (newLocation === currentDragHover) return; 
  currentDragHover = newLocation;
  
  $('#board .highlight-danger-source').removeClass('highlight-danger-source');
  
  if (newLocation === 'offboard') return;

  dragSimGame.load(game.fen());

  const move = dragSimGame.move({ from: source, to: newLocation, promotion: 'q' });
  if (move) {
      const enemyMoves = dragSimGame.moves({ verbose: true });
      const attackers = enemyMoves.filter(m => m.to === newLocation);
      if (attackers.length > 0) {
        attackers.forEach(m => $('#board .square-' + m.from).addClass('highlight-danger-source'));
      }
  }
}

function onDrop(source, target) {
  removeHighlights();
  $('.highlight-danger-source').removeClass('highlight-danger-source');
  
  const wasInCheck = game.in_check();
  const move = game.move({ from: source, to: target, promotion: 'q' });

  if (move === null) {
    if (wasInCheck) ui.msg.text(getRandomMsg('ignoreCheck')); 
    else ui.msg.text(getRandomMsg('invalidMove')); 
    return 'snapback'; 
  }

  playSound(move.flags.includes('c') ? 'capture' : 'move');
  
  updateTurnMessage(move, true); // isPlayerMove = true
  updateStatus(move);
  
  gameLoop();
}

function onSnapEnd() { board.position(game.fen()); }

// === AIã®å½¢å‹¢åˆ¤æ–­ã‚¹ã‚³ã‚¢ã‚’å–å¾— (AIè¦–ç‚¹ã®ã‚¹ã‚³ã‚¢) ===
function getAiScore() {
    const rawScore = getBoardValue(game);
    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒç™½ãªã‚‰ã€AIã¯é»’ãªã®ã§ -rawScore ãŒAIã®ã‚¹ã‚³ã‚¢
    return (playerColor === 'w') ? -rawScore : rawScore;
}

// === AIã®ç²¾ç¥çŠ¶æ…‹ã‚’å–å¾— (Winning / Losing / Even) ===
function getAiState(score) {
    if (score > 250) return "Winning";
    if (score < -250) return "Losing";
    return "Even";
}

// === ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æ›´æ–°ãƒ­ã‚¸ãƒƒã‚¯ (å½¢å‹¢å„ªå…ˆãƒ»ãƒãƒˆãƒªãƒƒã‚¯ã‚¹å‹) ===
function updateTurnMessage(move, isPlayerMove) {
    if (game.game_over()) return; 

    const score = getAiScore();
    const state = getAiState(score);
    
    let eventType = "move"; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
    if (game.in_check()) eventType = "check";
    else if (move.flags.includes('c')) eventType = "capture";

    // ã‚¢ã‚¯ã‚¿ãƒ¼ (èª°ãŒãã®ã‚¤ãƒ™ãƒ³ãƒˆã‚’èµ·ã“ã—ãŸã‹)
    const actor = isPlayerMove ? "player" : "ai";
    
    // ã‚­ãƒ¼ç”Ÿæˆ: ä¾‹ "ai_check_Losing" (AIãŒåŠ£å‹¢ãªã®ã«ç‹æ‰‹ã‚’ã‹ã‘ãŸ -> è‹¦ã—ç´›ã‚Œ)
    const key = `${actor}_${eventType}_${state}`;
    
    // è¾æ›¸ã‹ã‚‰å–å¾— (ãªã‘ã‚Œã°ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®åå¿œ)
    if (msgDict[key]) {
        ui.msg.text(getRandomMsg(key));
    } else {
        // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼ˆé€šå¸¸ç§»å‹•ãªã©ï¼‰
        ui.msg.text(getRandomMsg(`${actor}_move_${state}`));
    }
}

// === é¡”ãƒ»ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°ãƒ­ã‚¸ãƒƒã‚¯ ===
function updateStatus(lastMove) {
  const rawScore = getBoardValue(game);
  const aiScore = getAiScore();
  const aiState = getAiState(aiScore);

  // 1. ã‚²ãƒ¼ã‚¸æ›´æ–° (ç™½ç•ªåŸºæº–ã®ã‚¹ã‚³ã‚¢ã§è¡¨ç¤º)
  // ã‚¹ã‚³ã‚¢ãŒæ­£ãªã‚‰ç™½æœ‰åˆ©ã€‚ã‚²ãƒ¼ã‚¸50%ã‚’0ã¨ã—ã¦ãƒãƒƒãƒ”ãƒ³ã‚°
  const pct = (1 / (1 + Math.exp(-rawScore / 500))) * 100;
  ui.evalWhite.css('width', pct + '%');
  
  const isMyTurn = (game.turn() === playerColor);
  
  // æ ç·šæ¼”å‡º
  if (isMyTurn) ui.face.addClass('active-turn');
  else ui.face.removeClass('active-turn');

  // === é¡”ã‚¢ã‚¤ã‚³ãƒ³æ±ºå®šãƒ­ã‚¸ãƒƒã‚¯ ===

  // A. ã‚²ãƒ¼ãƒ çµ‚äº†æ™‚
  if(game.game_over()) {
    ui.btnRetry.removeClass('hidden'); ui.btnAuto.hide(); ui.btnHint.hide(); ui.btnUndo.hide();
    
    if(game.in_checkmate()) {
        const playerLost = (game.turn() === playerColor);
        if (playerLost) {
            ui.status.text("ã‚ãªãŸã®è² ã‘ (ã–ãã“â™¡)");
            ui.msg.html(getRandomMsg('win')); 
            ui.face.text(getRandom(EMOJI_WINNING));
        } else {
            ui.status.text("ã‚ãªãŸã®å‹ã¡ï¼(å‚ã‚Šã¾ã—ãŸ)");
            ui.msg.html(getRandomMsg('lose')); 
            ui.face.text(getRandom(EMOJI_LOSING));
        }
    } else {
        ui.status.text("å¼•ãåˆ†ã‘");
        ui.msg.text(getRandomMsg('draw'));
        ui.face.text(getRandom(EMOJI_NORMAL));
    }
    return;
  }
  
  ui.status.text(isMyTurn ? "ã‚ãªãŸã®ç•ª" : "ç›¸æ‰‹ã®ç•ª");
  if(board) board.draggable = (isMyTurn && !isAuto && !game.game_over());

  // B. ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ‰‹ç•ªä¸­ (AIã¯å¾…æ©Ÿä¸­)
  if (isMyTurn) {
      if (game.in_check()) {
          // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒç‹æ‰‹ã•ã‚Œã¦ã„ã‚‹
          ui.face.text(EMOJI_SCARED);
          ui.boardWrap.addClass('in-check-danger');
      } else {
          ui.face.text(isAuto ? EMOJI_ROBOT : EMOJI_SELF);
          ui.boardWrap.removeClass('in-check-danger');
      }
      return;
  }

  // C. AIã®æ‰‹ç•ª (æ€è€ƒä¸­ãƒ»ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³)
  ui.boardWrap.removeClass('in-check-danger');

  // ç›´å‰ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æ‰‹ã«å¯¾ã™ã‚‹ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆçŸ­æœŸçš„ãªæ„Ÿæƒ…ï¼‰
  // AIãŒåŠ£å‹¢(Losing)ãªã‚‰ã€ä½•ãŒèµ·ãã¦ã‚‚åŸºæœ¬ã¯è¾›ãã†ã«ã™ã‚‹
  
  if (aiState === "Losing") {
      ui.face.text(getRandom(EMOJI_LOSING)); // åŸºæœ¬çš„ã«æ³£ãé¡”/ç„¦ã‚Šé¡”
      return;
  }
  
  if (aiState === "Winning") {
      ui.face.text(getRandom(EMOJI_WINNING)); // åŸºæœ¬çš„ã«ãƒ‰ãƒ¤é¡”
      return;
  }

  // æ¥æˆ¦(Even)ã®å ´åˆã€ç›´å‰ã®ã‚¤ãƒ™ãƒ³ãƒˆã«åå¿œã™ã‚‹
  if (lastMove) {
      // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒæŒ‡ã—ãŸç›´å¾Œ
      if (game.turn() === playerColor) { // AIã®æ‰‹ç•ªã®ã¨ãã¯ game.turn() == playerColor ã§ã¯ãªã„(é€†)
         // ã“ã“ã¯ makeAiMove ç­‰ã§å‘¼ã°ã‚Œã‚‹éš›ã¯çŠ¶æ³ãŒç•°ãªã‚‹ãŸã‚ã€
         // ã€Œä»ŠAIã®æ‰‹ç•ªã§ã‚ã‚‹ã€ï¼ã€Œç›´å‰ã¯ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒæŒ‡ã—ãŸã€
      }
      
      const isPlayerJustMoved = (game.turn() !== playerColor); // ä»ŠAIã®æ‰‹ç•ª
      
      if (isPlayerJustMoved) {
          if (game.in_check()) {
               ui.face.text("ğŸ˜µâ€ğŸ’«"); // ç‹æ‰‹ã•ã‚ŒãŸã‚‰é©šã
               ui.boardWrap.addClass('in-check-danger');
               return;
          }
          if (lastMove.flags.includes('c')) {
               ui.face.text("ğŸ˜ "); // é§’ã‚’å–ã‚‰ã‚ŒãŸã‚‰æ€’ã‚‹
               return;
          }
      }
  }

  // ç‰¹ã«ã‚¤ãƒ™ãƒ³ãƒˆãŒãªã„æ¥æˆ¦æ™‚ã¯æ™®é€š/æ€è€ƒä¸­
  ui.face.text(getRandom(EMOJI_NORMAL));
}

function toggleAutoPlay() {
  if(game.game_over()) return;
  isAuto = !isAuto;
  
  if(isAuto) {
    removeHighlights();
    ui.btnHint.prop('disabled', true).addClass('btn-disabled');
    ui.btnUndo.prop('disabled', true).addClass('btn-disabled');
    ui.btnAuto.addClass('btn-auto-active').text("ğŸ¤– ON");
    ui.msg.text(getRandomMsg('autoOn'));
    gameLoop();
  } else {
    ui.btnHint.prop('disabled', false).removeClass('btn-disabled');
    ui.btnUndo.prop('disabled', false).removeClass('btn-disabled');
    ui.btnAuto.removeClass('btn-auto-active').text("ğŸ¤– OFF");
    clearTimeout(autoTimer);
    if (game.turn() === playerColor) {
        ui.msg.text("ã‚„ã£ã¨è‡ªåˆ†ã§ã‚„ã‚‹æ°—ã«ãªã£ãŸï¼Ÿ");
    } else {
        ui.msg.text("ç§ã®ç•ªã ã‘ã©ï¼Ÿ");
    }
    if(game.turn() !== playerColor) {
       gameLoop(); 
    }
    updateStatus(null);
  }
}

function undoMove() {
  if(!isAuto && !game.game_over() && game.turn()===playerColor && game.history().length>=2) {
    game.undo(); game.undo(); 
    board.position(game.fen()); 
    removeHighlights();
    $('.highlight-danger-source').removeClass('highlight-danger-source'); 
    ui.msg.text(getRandomMsg('undo')); 
    updateStatus(null);
  }
}

function showHint() {
  if(game.turn()!==playerColor || isAuto) return;
  ui.msg.text("ãƒ’ãƒ³ãƒˆï¼Ÿ ã—ã‚‡ã†ãŒãªã„ãªã...");
  setTimeout(() => {
      const m = getBestMove(3); 
      if(m) {
          const obj = game.move(m); game.undo();
          $('#board .square-'+obj.from).addClass('highlight-hint');
          $('#board .square-'+obj.to).addClass('highlight-hint');
          ui.msg.text(getRandomMsg('hint'));
      }
  }, 100);
}

function removeHighlights() {
  $('#board [class*="square"]').removeClass('highlight-move highlight-capture highlight-hint');
}
</script>
</body>
</html>